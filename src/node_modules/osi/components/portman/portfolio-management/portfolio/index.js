import React, { Component, PureComponent } from 'react'
import { connect } from 'react-redux'
import _ from 'lodash'
import { Link, browserHistory } from 'react-router'

import { bindActionCreators } from 'redux'
import { isEtherAddress } from '../../../../../../utils'

import * as userActions from '../../../../../../actions/user.actions'
import * as portfolioActions from '../../../../../../actions/portfolio.actions'
import * as balancesActions from '../../../../../../actions/balances.actions'
import * as chartActions from '../../../../../../actions/chart.actions'

import ActionDone from 'material-ui/svg-icons/action/done'
import TextField from 'react-md/lib/TextFields'

import { Avatar, ToolbarGroup, Toolbar, ToolbarTitle, IconButton } from 'material-ui'
import { Spinner } from 'osi/bits'
import PortfolioAvatar from 'osi/bits/portfolio-avatar'
import CircularProgress from 'material-ui/CircularProgress'
import AVPlay from 'material-ui/svg-icons/av/play-circle-filled'

import NavigationMoreVert from 'material-ui/svg-icons/navigation/more-vert'
import EditorModeEdit from 'material-ui/svg-icons/editor/mode-edit'

import './portfolio.css'
import WebFont from 'webfontloader'
import Button from 'react-md/lib/Buttons/Button'
import Paper from 'react-md/lib/Papers'
import CardTitle from 'react-md/lib/Cards/CardTitle'
import List from 'react-md/lib/Lists/List'
import ListItem from 'react-md/lib/Lists/ListItem'
import FontIcon from 'react-md/lib/FontIcons'
import Dialog from 'react-md/lib/Dialogs'

import DataTable from 'react-md/lib/DataTables/DataTable'
import TableHeader from 'react-md/lib/DataTables/TableHeader'
import TableBody from 'react-md/lib/DataTables/TableBody'
import TableRow from 'react-md/lib/DataTables/TableRow'
import TableColumn from 'react-md/lib/DataTables/TableColumn'
import TableCardHeader from 'react-md/lib/DataTables/TableCardHeader'

import EthereumIcon from 'osi/bits/svg-icons/network/ethereum'

import PerformanceChart from 'osi/components/portman/parts/charts/performance'
import CreatePortfolio from 'osi/components/portman/parts/create-portfolio'
import CalculatePortfolio from 'osi/components/portman/parts/calculate-portfolio'
import MessageBlock from 'osi/components/portman/parts/message-block'
import PageContent from 'osi/components/portman/parts/page-content'

import {Card, CardActions, CardHeader, CardText} from 'material-ui/Card'
import FlatButton from 'material-ui/FlatButton'
import AlertDialog from 'osi/components/portman/parts/dialogs/alert-dialog'

import IconMenu from 'material-ui/IconMenu'
import NavigationExpandMoreIcon from 'material-ui/svg-icons/navigation/expand-more'
import MenuItem from 'material-ui/MenuItem'
import DropDownMenu from 'material-ui/DropDownMenu'
import RaisedButton from 'material-ui/RaisedButton'
import { ToolbarSeparator } from 'material-ui/Toolbar'

import NavigationArrowBack from 'material-ui/svg-icons/navigation/arrow-back'
import NavigationRefresh from 'material-ui/svg-icons/navigation/refresh'
import ActionDelete from 'material-ui/svg-icons/action/delete'
import ActionFavorite from 'material-ui/svg-icons/action/favorite'
import ActionSearch from 'material-ui/svg-icons/action/search'
import SocialShare from 'material-ui/svg-icons/social/share'
import ContentAdd from 'material-ui/svg-icons/content/add'
import { currencyFormat } from 'osi/config'
import AddTokenDialog from 'osi/pages/dashboard/dialogs/add-token.dialog'

const DEBUG = false

import { FirstCalc, AssociateAddresses, CalculatingPortfolio } from './onboarding'

class Portfolio extends Component {
  constructor (props) {
    super(props)

    this.state = {
      init: true,
      associateOpen: false,
      alertOpen: false,
      ready: false,
      showAddToken: false,
      progressStatus: 23
    }

    this.checkIfReady = _.debounce(this.checkIfReady, 250)
  }

  componentDidMount () {
    const { calculations, portfolio, portfolioActions, process: pProcess, balances } = this.props
    if (portfolio && portfolio.portfolio && portfolio.portfolio.lastCalculated) {
      let shouldIupdate = (!pProcess || !pProcess.fetching) && // not fetching, and
        (!calculations || !calculations.chartData || !calculations.dayDataByDate) // doesn't have calculations

      shouldIupdate && portfolioActions.loadPortfolioCalculations(portfolio.portfolio.pid)
    }
    this.checkIfReady()
  }

  componentWillReceiveProps (nextProps) {
    if (!this.state.ready) this.checkIfReady()
  }
  openAssociateAddress () {
    this.setState({associateOpen: true})
  }

  checkIfReady () {
    const { shouldWaitForCalculations, hasCalculation, shouldWaitForBalances, hasBalances } = this.props

    DEBUG && console.group('Check if Ready')
    const done = m => {
      DEBUG && console.log('D0N3D0N3D0N3D0N3D0N3D0N3D0N3D0N3D0N3D0N3D0N3D0N3')
      DEBUG && console.log('D0N3D0N3D0N3D0N3D0N3D0N3D0N3D0N3D0N3D0N3D0N3D0N3')
      DEBUG && console.log('D0N3D0N3D0N3D0N3D0N3D0N3D0N3D0N3D0N3D0N3D0N3D0N3')
      DEBUG && console.log('D0N3D0N3D0N3D0N3D0N3D0N3D0N3D0N3D0N3D0N3D0N3D0N3')
      DEBUG && console.log('Set state to', true, 'for:', m)
      DEBUG && console.groupEnd()
      this.setState({ready: true})
    }

    const ignoreProps = 'singularPortfolio, location, params, user, hasUser, routeParams, route, router, routes, children'.split(', ')

    DEBUG && Object.keys(this.props)
      .filter(e => ignoreProps.indexOf(e) === -1)
      .map(e => console.log(`prop.${e} = `, this.props[e]))
    if (this.state.init) {

      const calcReady = (shouldWaitForCalculations && hasCalculation) || !shouldWaitForCalculations
      const balancesReady = (shouldWaitForBalances && hasBalances) || !shouldWaitForBalances
      if (calcReady && balancesReady) done('calcReady && balancesReady')
    }
    DEBUG && console.groupEnd()
  }

  onAssociateAddress (address) {
    const { portfolio, portfolioActions } = this.props
    portfolioActions.associateAddressToPortfolio(portfolio, address)
      .then(_ => this.setState({associateOpen: false})) // close dialog
      .then(_ => portfolioActions.loadUserPortfolios(this.props.user.profile.uid)) // reload portfolios
  }

  deleteAddress (address, key) {
    const { portfolio, portfolioActions } = this.props
    portfolioActions.removeAddressFromPortfolio(portfolio, address, key)
      .then(_ => portfolioActions.loadUserPortfolios(this.props.user.profile.uid)) // reload portfolios
  }

  startPortfolio ({disablePortfolio = false, disableBalances = false} = {}) {
    const { portfolio, chartActions, balancesActions, addressList = [] } = this.props
    console.log('starting!', portfolio)

    if (!addressList.length) {
      this.setState({
        alertOpen: true,
        alertTitle: 'No addresses associated',
        alertText: 'Associate addresses with this portfolio to begin calculations'
      })
    } else {
      const customTokens = this.getPortfolioTokens()
      !disableBalances && balancesActions.calcBalances(portfolio.portfolio.pid, addressList, customTokens)
        // .then(result => this.associateIdentifiedTokens(result))
      !disablePortfolio && chartActions.calcPortfolio(portfolio.portfolio.pid, addressList, customTokens)
    }
  }

  getPortfolioTokens () {
    const { portfolio } = this.props
    const { tokens } = (portfolio && portfolio.portfolio) || {}
    const tokenKeys = (tokens && Object.keys(tokens)) || []
    const tokensArray = tokenKeys.map(k => Object.assign({}, tokens[k]))

    console.log('tokensArray', tokensArray)
    return tokensArray
  }

  associateIdentifiedTokens (data) {
    const { portfolio, portfolioActions: { associateTokenToPortfolio } } = this.props
    const { balances, baseTokens } = data
    const portfolioTokens = this.getPortfolioTokens()
    if (!balances.length) return false

    const symbols = balances.map(e => e.title)
    const identifiedTokens = baseTokens.filter(e => symbols.indexOf(e.symbol) >= 0)
    const portfolioSymbols = portfolioTokens.map(e => e.symbol)

    const missingTokens = identifiedTokens.filter(e => portfolioSymbols.indexOf(e.symbol) === -1)
    console.log('associating identified tokens:', symbols, identifiedTokens)
    console.log('portfolioTokens:', portfolioTokens)
    console.log('missing tokens:', missingTokens)

    missingTokens.map(t => {
      let token = Object.keys(t).filter(e => !!t[e]).reduce((acc, val) => Object.assign(acc, {[val]: t[val]}), {})
      associateTokenToPortfolio(portfolio.portfolio.pid, token)
        .then(result => portfolioActions.loadUserPortfolios(this.props.user.profile.uid))
    })
  }
  render () {
    const { pid } = this.props.routeParams
    const { portfolio, addressList, processProgress, calculationError, process, balances, chartActions, balancesActions } = this.props
    const { hasCalculation, hasBalances, hasAddresses } = this.props
    const onboarding = !hasAddresses || (!hasBalances || !hasCalculation) || (processProgress && (processProgress > 0 && !process.completed))
    const firstCalc = (!balances || !balances.data || balances.data.length === 0) && !processProgress && process && !process.fetching
    const calculating = process && process.started && !process.completed && !process.fetching && (processProgress > 0 && processProgress < 100)

    if (!portfolio || !portfolio.portfolio || !this.state.ready) return <Spinner>Loading...</Spinner>

    const calcs = _.cloneDeep(this.props.calculations)

    return (
      <div className={['portfolio', pid].join(' ')}>
        <PageContent>
          <header className='tested'>
            <PortfolioHead
              doBalances={e => this.startPortfolio({disablePortfolio: true})}
              doCalculate={e => this.startPortfolio()}
              portfolio={portfolio}
              processProgress={processProgress}
              calculationError={calculationError}
              process={process}
              addressList={addressList}
              chartActions={chartActions}
              balancesActions={balancesActions}
              isSingular={this.props.singularPortfolio}
            />
          </header>
          {onboarding && <multi className='onboarding'>
            { /* Check if (hasNoCalculation, notCalculating, hasNoAddresses) */ }
            {!hasAddresses && (
              <AssociateAddresses doAssociate={e => this.openAssociateAddress()} />
            )}

            { /* Check if (hasNoCalculation, notCalculating, hasAddresses) */ }
            {hasAddresses && !hasCalculation && !processProgress && (
              <FirstCalc
                doCalc={e => this.startPortfolio()}
              />
            )}

            { /* Check if (hasNoCalculation, notCalculating, hasAddresses) */ }
            {hasAddresses && !!processProgress && (
              <CalculatingPortfolio
                status={processProgress}
              />
            )}
          </multi>}
          <primary>
            {hasCalculation && (
              <Card className='tested'>
                <CardHeader
                  title='Balance'
                />
                <CardText>
                  <h3 className='md-display-2'>
                    {balances.data && balances.data.length && balances.data.reduce((acc, val) => acc + val.value, 0).toLocaleString(...currencyFormat)}
                  </h3>

                  {calcs && (
                    <PerformanceChart calculations={calcs} />
                  )}
                </CardText>
              </Card>
            )}

            {hasAddresses && addressList.length > 0 && (
              <Card className='addresses' style={{padding: 0}}>
                <CardHeader
                  className='title'
                  title='Associated Addresses'
                >
                  <div className='actions'>
                    <Button icon primary tooltipLabel='Add' onClick={e => this.openAssociateAddress()}>
                      <ContentAdd />
                    </Button>
                  </div>
                </CardHeader>
                <CardText className='card-table' style={{padding: 0}}>

                  {/* Begin Addresses List */}

                  {addressList.length > 0 && (
                    <DataTable
                      responsive={false}
                      plain>
                      <TableHeader>
                        <TableRow>
                          <TableColumn className='icon'>{/* Icon */}</TableColumn>
                          <TableColumn className='address'>Addresses</TableColumn>
                          <TableColumn className='actions'>{/* Actions */}</TableColumn>
                        </TableRow>
                      </TableHeader>
                      <TableBody>
                        {addressList.map(({address, type, key}) => {
                          return (
                            <TableRow key={key} autoAdjust={false}>
                              <TableColumn className='icon'>{type === 'eth' && <EthereumIcon size={28} />}</TableColumn>
                              <TableColumn className='address'>{address}</TableColumn>
                              <TableColumn className='actions'>
                                <Button
                                  flat tooltipLabel='Delete Address' onClick={e => this.deleteAddress(address, key)}><ActionDelete /></Button>
                              </TableColumn>
                            </TableRow>
                          )
                        })}
                      </TableBody>
                    </DataTable>
                  )}

                  {/* End Addresses List */}

                </CardText>
              </Card>
            )}
          </primary>
          <secondary>
            {hasBalances && balances && balances.data && balances.data.length && (
              <Card className='tokens'>

                <CardHeader
                  className='title'
                  title='Tokens Allocation'>
                  <div className='actions'>
                    <Button icon primary tooltipLabel='Add' onClick={e => this.setState({showAddToken: true})}>
                      <ContentAdd />
                    </Button>
                    <AddTokenDialog open={this.state.showAddToken} portfolio={portfolio} then={(...args) => this.setState({showAddToken: false})} />
                  </div>
                </CardHeader>

                <CardText className='card-table' style={{padding: 0}}>

                  {balances && balances.data && balances.data.length && (
                  <DataTable
                    responsive={false}
                    plain>
                    <TableHeader>
                      <TableRow>
                        <TableColumn className='icon'>{/* Icon */}</TableColumn>
                        <TableColumn>Name</TableColumn>
                        <TableColumn>Value</TableColumn>
                      </TableRow>
                    </TableHeader>
                    <TableBody>
                      {balances.data.map(({title, amount, value}, index) => {
                        return (
                          <TableRow key={index}>
                            <TableColumn className='icon'>{title === 'ETH' && <EthereumIcon size={28} />}</TableColumn>
                            <TableColumn>{title}</TableColumn>
                            <TableColumn numeric>{value.toLocaleString(...currencyFormat)}</TableColumn>
                          </TableRow>
                        )
                      })}
                    </TableBody>
                  </DataTable>
                  )}
                </CardText>
              </Card>
            )}
            {/*
              <Paper zDepth={1}>
                <h4>Can't see your tokens here?</h4>
                <p>Use the custom token feature to add your token and track it here</p>
                <div className='actions'>
                  <Button raised label='Add custom token' primary />
                </div>
              </Paper>
              */}
          </secondary>
          {this.props.singularPortfolio && (<footer>
            <NewPortfolio />
          </footer>)}
        </PageContent>
        <AssociateDialog
          portfolio={this.props.portfolio}
          addressList={addressList}
          onSubmit={address => this.onAssociateAddress(address)}
          onClose={e => this.setState({associateOpen: false})}
          isOpen={this.state.associateOpen} />

        <AlertDialog
          onClose={e => this.setState({alertOpen: false})}
          visible={this.state.alertOpen}
          title={this.state.alertTitle}
          >
          <div>{this.state.alertText}</div>
        </AlertDialog>
      </div>
    )
  }
}

class AssociateDialog extends PureComponent {
  constructor (props) {
    super(props)

    this.state = {
      isAddress: false,
      addressExists: false,
      error: false
    }
  }

  addressUpdate () {
    const address = this.refs.address.getField().value
    const isAddress = isEtherAddress(address)

    const { addressList = [] } = this.props
    const addressExists = !!addressList.find(e => e.address === address)

    if (
        ((!isAddress && this.state.isAddress) || (isAddress && !this.state.isAddress)) ||
        ((addressExists && !this.state.addressExists) || (!addressExists && this.state.addressExists))
      ) {
      this.setState({isAddress, addressExists})
    }
  }

  onSubmit (e) {
    const address = this.refs.address.getField().value
    const { isAddress, addressExists } = this.state

    e.preventDefault()

    if (isAddress && !addressExists) {
      this.props.onSubmit(address)
    } else if (addressExists) {
      this.setState({error: {
        address,
        addressExists
      }})
    } else {
      this.setState({error: {
        address,
        isAddress
      }})
    }
  }
  render () {
    const { isOpen, onClose } = this.props
    const { error } = this.state
    const errorText = error && ((error.isAddress && 'Value is not a valid ethereum address') || (error.addressExists && 'Address already exists'))
    return (
      <Dialog
        id='associate-address'
        visible={isOpen}
        title='Associate address with portfolio'
        onHide={e => {
          this.setState({error: false, isAddress: false, addressExists: false})
          onClose(e)
        }}
        aria-labelledby='Associate account...'
        component='div'
        closeOnEsc
        actions={[{
          onClick: onClose,
          primary: !this.state.isAddress,
          label: 'Cancel'
        }, {
          onClick: e => this.onSubmit(e),
          primary: true,
          disabled: !this.state.isAddress,
          label: 'Submit'
        }]}
       >

        <p>Enter a valid Ethereum address:</p>
        <form onSubmit={e => this.onSubmit(e)} className='address'>
          <TextField
            id='address'
            ref='address'
            label='Account address'
            type='text'
            error={!!error}
            errorText={errorText}
            helpText='e.g. 0x71CF9f77F1...'
            onChange={e => this.addressUpdate(e)}
            rightIcon={this.state.isAddress ? <ActionDone size={28} /> : (<span>&nbsp;</span> || (false && <CircularProgress size={28} />))}
            className='md-cell md-cell--bottom' />
        </form>

      </Dialog>
    )
  }
}

class StatCard extends Component {
  render () {
    return (
      <Card className='indicator-card'>
        <CardTitle title={this.props.title} />
        <CardText className='weather-block'>
          <h2 className='md-display-2 display-override'>{this.props.value}</h2>
        </CardText>
        {false && <CardActions className='md-divider-border md-divider-border--top'>
          <Button flat label='Full Report' />
        </CardActions>}
      </Card>
    )
  }
}

const NewPortfolio = props => {
  return (
    <div className='new-portfolio'>
      <span className='msg'>
        Need more than one portfolio?
      </span>

      <CreatePortfolio label='Add Portfolio' raised onCreate={(pf) => {
        browserHistory.push(`/p/${pf.portfolio.pid}`)
      }} />
    </div>
  )
}

class PortfolioHead extends Component {
  constructor (props) {
    super(props)

    this.state = {
      value: 3
    }
  }

  handleChange (event, index, value) {
    this.setState({value})
  }

  render () {
    const { portfolio, isSingular, addressList, chartActions, balancesActions, process, processProgress } = this.props
    const alignToStart = { alignItems: 'flex-start' }
    const whiteIcon = { color: '#FFF' }
    return (
      <Paper zDepth={1} className='portfolio-head'>
        <Toolbar className='one' style={{
          background: 'rgba(52, 84, 209, 1)'
        }}>

          {!isSingular && (
            <ToolbarGroup className='back' style={alignToStart}>
              <Link to='/portfolios'>
                <IconButton touch style={whiteIcon}>
                  <NavigationArrowBack color='#FFF' />
                </IconButton>
              </Link>
            </ToolbarGroup>
          )}

          <ToolbarGroup style={alignToStart} className='actions' lastChild>
            <IconButton tooltip='Search Portfolio' onClick={e => this.props.doBalances()}>
              <ActionSearch color='#FFF' />
            </IconButton>

            <IconButton tooltip='Share Portfolio' disabled>
              <SocialShare color='#FFF' />
            </IconButton>

            <IconButton tooltip='Recalculate Portfolio' onClick={e => this.props.doCalculate()}>
              <NavigationRefresh color='#FFF' />
            </IconButton>

            <IconButton disabled tooltip='Add to Favorites'>
              <ActionFavorite color='#FFF' />
            </IconButton>
            <IconButton disabled tooltip='Delete Portfolio'>
              <ActionDelete color='#FFF' />
            </IconButton>
            <IconButton disabled tooltip='Portfolio Settings'>
              <NavigationMoreVert color='#FFF' />
            </IconButton>
            {'icon menu for later' === 'not now' && (
              <IconMenu
                iconButtonElement={
                  <IconButton touch style={whiteIcon}>
                    <NavigationMoreVert color='#FFF' />
                  </IconButton>
                  }
                >
                <MenuItem primaryText='Download' />
                <MenuItem primaryText='More Info' />
              </IconMenu>
            )}
          </ToolbarGroup>
        </Toolbar>

        <Toolbar className='two' style={{
          background: 'rgba(52, 84, 209, 1)'
        }}>
          <ToolbarGroup className='titles' style={alignToStart}>
            <PortfolioAvatar portfolio={portfolio} />
            <ToolbarTitle text={portfolio.portfolio.name} className='title' style={whiteIcon} />
          </ToolbarGroup>
        </Toolbar>
      </Paper>
    )
  }
}

// const CalculatePortfolio = connect(mapStateToProps, mapDispatchToProps)(_CalculatePortfolio)

function mapStateToProps (state, ownProps) {
  const { pid } = ownProps.routeParams
  const { portfolios = [], userPortfolios } = state.portfolio
  const portfolio = portfolios.find(e => e.portfolio.pid === pid)

  const { addresses = {} } = (portfolio && portfolio.portfolio) || {}

  const addressList = Object.keys(addresses).map(key => ({...addresses[key], key}))

  const calculations = state.portfolio && state.portfolio.calculations ? state.portfolio.calculations[pid] : null
  const process = state.portfolio.process[pid]

  const { log = [] } = (process && process.started && process) || {}
  const progressLog = log.filter(l => l.type === 'PORTFOLIO_CALCULATION_UPDATE')
  const processProgress = progressLog && progressLog.length && progressLog[progressLog.length - 1].progress
  const calculationError = log.find(l => l.type === 'PORTFOLIO_CALCULATION_ERROR')

  const balances = (state.balances && state.balances.byPid && state.balances.byPid[pid]) || []

  // /// /// /// /// /// /// //

  const shouldWaitForCalculations = portfolio && !!portfolio.portfolio.lastCalculated
  const lastCalculated = portfolio && portfolio.portfolio.lastCalculated
  const hasCalculation = lastCalculated && !!calculations

  const shouldWaitForBalances = portfolio && !!portfolio.portfolio.lastBalances
  const lastBalances = portfolio && balances && balances.updatedOn
  const hasBalances = portfolio && balances && !!balances.updatedOn

  const hasAddresses = portfolio && addressList && !!addressList.length

  return {
    user: state.user,
    singularPortfolio: userPortfolios.length === 1,
    portfolio,
    addressList,
    calculations,
    process,
    processProgress,
    calculationError,
    balances,

    shouldWaitForCalculations,
    hasCalculation,
    lastCalculated,
    shouldWaitForBalances,
    hasBalances,
    lastBalances,
    hasAddresses
  }
}

function mapDispatchToProps (dispatch) {
  return {
    balancesActions: bindActionCreators(balancesActions, dispatch),
    userActions: bindActionCreators(userActions, dispatch),
    portfolioActions: bindActionCreators(portfolioActions, dispatch),
    chartActions: bindActionCreators(chartActions, dispatch)
  }
}

export default connect(mapStateToProps, mapDispatchToProps)(Portfolio)

export const onRouteEnter = (nextState, replace) => {
  // done()
}
