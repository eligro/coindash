import React from 'react'
import { connect } from 'react-redux'
import { Link } from 'react-router'
import { bindActionCreators } from 'redux'
import { Button, OverlayTrigger, Tooltip, Modal } from 'react-bootstrap'
import _ from 'lodash'
import FontAwesome from 'react-fontawesome'
import Spinner from '../../../../components/common/Spinner.react'

import * as coinActions from '../../../../actions/coins.actions'
import * as chartActions from '../../../../actions/chart.actions'
import * as balancesActions from '../../../../actions/balances.actions'

import Card from '../../components/card/card.react'
import AddTokenDialog from './dialogs/add-token.dialog'
import { recordEvent } from 'osi/analytics'

import './dashboard.css'

import BalanceCard from './cards/balance-card.react'
import ChartsCard from './cards/charts-card.react'
import PositionCard from './cards/position-card.react'

export const Flex = () => <div style={{flex: '1 1 auto'}} />

const frontCoins = [
  {name: 'Bitcoins', short: 'BTC'},
  {name: 'Ethereum', short: 'ETH'},
  {name: 'Ripple', short: 'XRP'},
  {name: 'Litecoin', short: 'LTC'},
  {name: 'Monero', short: 'MXR'},
  {name: 'Ethereum Classic', short: 'ETC'},
  {name: 'Dash', short: 'DASH'},
  {name: 'Augur', short: 'REP'},
  {name: 'Steem', short: 'STEAM'},
  {name: 'NEM', short: 'XEM'},
  {name: 'MaidSafeCoin', short: 'MAID'},
  {name: 'Waves', short: 'WAVES'},
  {name: 'Dogecoin', short: 'DOGE'},
  {namr: 'Factom', short: 'FCT'},
  {name: 'DigixDAO', short: 'DGD'},
  {name: 'Lisk', short: 'LSK'},
  {name: 'Iconomi', short: 'ICN'},
  {name: 'Peerplays', short: 'PEERPLAYS'},
  {name: 'Gulden', short: 'NLG'},
  {name: 'GameCredit', short: 'GAME'}
]

const frontShort = frontCoins.map(item => item.short)

class HomePage extends React.Component {
  constructor (props, context) {
    super(props, context)

    this.state = {
      selectedChart: 1,
      showError: true,
      showAddToken: false,
      token: {
        address: '',
        symbol: '',

        decimal: '',
        ico_contract_address: ''
      },
      userInitialized: false,
      starred: []
    }

    this.closeError = this.closeError.bind(this)
    this.openAddToken = this.openAddToken.bind(this)
    this.closeAddToken = this.closeAddToken.bind(this)
    this.chartSelected = this.chartSelected.bind(this)
    this.refreshChart = this.refreshChart.bind(this)
  }

  componentWillMount () {
    this.props.coinActions.loadFront()
    this.startPoll()

  }

  componentWillUnmount () {
    this.stopPoll()
  }

  startPoll () {
    this.timeout = setTimeout(() => {
      this.props.coinActions.loadFront()
      this.startPoll()
    }, 20000)
  }

  stopPoll () {
    clearTimeout(this.timeout)
  }

  chartSelected (selected) {
    this.setState({selectedChart: selected})
  }

  refreshChart () {
    this.props.chartActions.setLoadedChart(false)
    this.props.chartActions.clearCharts()
    this.props.chartActions.loadChart()
    this.props.balancesActions.loadBalances()

    if (this.props.chartError) {
      this.setState({showError: true, userInitialized: true})
    } else {
      this.setState({userInitialized: true})
    }
  }

  closeError (event) {
    this.setState({showError: false})
  }

  openAddToken (event) {
    recordEvent('add token', { action: 'open' })
    this.setState({showAddToken: true})
  }

  closeAddToken (event) {
    recordEvent('add token', { action: 'close' })
    this.setState({showAddToken: false})
  }

  onAddToken (event) {
    recordEvent('add token', { action: 'added' })
    this.closeAddToken(event)
  }

  render () {
    let [hasAccounts, hasTokens] = [this.props.exchanges.length > 0, this.props.balances.length > 0]
    let allExchangesProcessed = !this.props.exchanges.find(e => !e.processed)
    const badErrorWithThisModal = false
    // return (<h1>Well...</h1>)
    return (
      <div className='page-container dashboard-page osi'>
        <div className='top-cont'>
          <BalanceCard {...this.props} openAddToken={this.openAddToken} />
          <ChartsCard {...this.props} refreshChart={this.refreshChart} />
        </div>
        {(hasAccounts && hasTokens) ||
          (!allExchangesProcessed && !this.state.userInitialized && hasAccounts &&
            <div className='top-cont fresh'>
              <Card title='Fresh Account' style={{margin: '0 auto'}}>
                <h1>First time...</h1>
                <p>It looks like you've just loaded up some fresh accounts, to get started click on the Initialize button below...</p>

                <Button bsStyle='primary' onClick={this.refreshChart}>
                  Intialize
                </Button>
              </Card>
            </div>
          ) ||
          (hasAccounts && !hasTokens &&
            <div className='top-cont'>
              <Card title='System Initializing...' headerActions={(
                <OverlayTrigger placement='bottom' overlay={<Tooltip id='add-token'>Reload</Tooltip>}>
                  <Button onClick={this.refreshChart} >
                    <FontAwesome name='refresh' />
                  </Button>
                </OverlayTrigger>
              )} style={{margin: '0 auto'}}>
                <h1>Stand by...</h1>
                <p>The system is parsing your accounts...</p>
                <h3>{this.props.statusText}</h3>
              </Card>
            </div>
          ) ||

          <div className='top-cont'>
            <Card>
              <h1>You do not have any Accounts defined</h1>
              <p>Please add your <Link to='/dashboard/accounts'>accounts</Link> to the system to proceed.</p>
            </Card>
          </div>
        }

        {(hasAccounts && hasTokens &&
          <Card title='Watchlist' className='positions'>
            {!this.props.front && <Spinner />}
            {this.props.front && this.props.front
              .map(e => Object.assign({}, e, {starred: this.state.starred.indexOf(e.short) >= 0}))
              .sort((a, b) => (a.starred && -1) || 0)
                .filter(item => frontShort.indexOf(item.short) > -1).map((item, index) => <PositionCard key={index} item={item} starToggle={(event) => this.starToggle(item)} starred={item.starred} />)}
          </Card>
        )}

        {badErrorWithThisModal && (
          <Modal show={this.props.chartError && this.state.showError} onHide={e => this.closeError(e)}>
            <Modal.Header closeButton>
              <Modal.Title>Error</Modal.Title>
            </Modal.Header>
            <Modal.Body>
              {this.props.chartError}
            </Modal.Body>
            <Modal.Footer>
              <Button onClick={this.closeError}>Got it</Button>
            </Modal.Footer>
          </Modal>
        )}
        <AddTokenDialog open={this.state.showAddToken} then={this.onAddToken.bind(this)} />
      </div>
    )
  }
  starToggle (ticker) {
    this.setState({starred: [ticker.short, ...this.state.starred]})
    // console.log('dispatch star event', ticker)
    // dispatch(starToekn(this.props.item))
  }
}

function mapStateToProps (state, ownProps) {
  let sorted = [...state.balances.sort((a, b) => a.value > b.value ? 1 : -1)]
  let [most, least] = [sorted.pop(), sorted.find(e => e.value >= 0.01)]

  const { portfolios, userPortfolios: userKeys } = state.portfolio
  const userPortoflios = portfolios.filter(pf => userKeys.indexOf(pf) >= 0)

  return {
    balances: state.balances,
    chartData: state.charts.chartData,
    performanceData: state.charts.preformanceData,
    portfolioDayDataByDate: _.cloneDeep(state.charts.portfolioDayDataByDate),
    front: state.coins.front,
    exchanges: state.exchanges,
    statusText: state.charts.statusText,
    balanceError: state.charts.balanceError,
    chartError: state.charts.error,
    userPortoflios,
    portfolios,
    balance: {
      // lastMonth: state.charts.chartData.portfolioAggDelta
      //   .filter(([date, value]) => date > lastMonth) // only last 30 days
      //   .filter((e, i, a) => i === 0 || i === a.length - 1) // first and last
      //   .filter((e, i, a) => console.info('last month e,i,a', e, i, a) || true)
      //   .reduce((t, [time, value]) => t > 0 ? value - t : value, 0),
      tokens: state.balances.length,
      most,
      least
    }
  }
}

function mapDispatchToProps (dispatch) {
  return {
    coinActions: bindActionCreators(coinActions, dispatch),
    chartActions: bindActionCreators(chartActions, dispatch),
    balancesActions: bindActionCreators(balancesActions, dispatch)
  }
}

export default connect(mapStateToProps, mapDispatchToProps)(HomePage)
