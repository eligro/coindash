import React, { Component } from 'react'
import { connect } from 'react-redux'
import { bindActionCreators } from 'redux'
import _ from 'lodash'

import * as userActions from '../../../../../../actions/user.actions'
import * as portfolioActions from '../../../../../../actions/portfolio.actions'
import * as balancesActions from '../../../../../../actions/balances.actions'
import * as chartActions from '../../../../../../actions/chart.actions'

import Button from 'react-md/lib/Buttons/Button'
import DataTable from 'react-md/lib/DataTables/DataTable'
import TableHeader from 'react-md/lib/DataTables/TableHeader'
import TableBody from 'react-md/lib/DataTables/TableBody'
import TableRow from 'react-md/lib/DataTables/TableRow'
import TableColumn from 'react-md/lib/DataTables/TableColumn'
import {Card, CardHeader, CardText} from 'material-ui/Card'
import ActionDelete from 'material-ui/svg-icons/action/delete'
import ActionSettings from 'material-ui/svg-icons/action/settings'
import ContentAdd from 'material-ui/svg-icons/content/add'
import './portfolio.css'

import { Spinner } from 'osi/bits'
import EthereumIcon from 'osi/bits/svg-icons/network/ethereum'
import AddTokenDialog from 'osi/pages/dashboard/dialogs/add-token.dialog'
import AlertDialog from 'osi/components/portman/parts/dialogs/alert-dialog'
import PerformanceChart from 'osi/components/portman/parts/charts/performance'
import PageContent from 'osi/components/portman/parts/page-content'
import { currencyFormat } from 'osi/config'
import { recordEvent } from 'osi/analytics'

import NewPortfolio from './new-portfolio'
import PortfolioHead from './portfolio-head'
import AssociateDialog from './associate-dialog'


const DEBUG = false

import { FirstCalc, AssociateAddresses, CalculatingPortfolio } from './onboarding'

class Portfolio extends Component {
  constructor (props) {
    super(props)

    this.state = {
      init: true,
      associateOpen: false,
      alertOpen: false,
      ready: false,
      showAddToken: false,
      progressStatus: 23
    }

    this.checkIfReady = _.debounce(this.checkIfReady, 250)
  }

  componentDidMount () {
    const { calculations, portfolio, portfolioActions, process: pProcess } = this.props
    if (portfolio && portfolio.portfolio && portfolio.portfolio.lastCalculated) {
      let shouldIupdate = (!pProcess || !pProcess.fetching) && // not fetching, and
        (!calculations || !calculations.chartData || !calculations.dayDataByDate) // doesn't have calculations

      shouldIupdate && portfolioActions.loadPortfolioCalculations(portfolio.portfolio.pid)
    }
    this.checkIfReady()
  }

  componentWillReceiveProps (nextProps) {
    if (!this.state.ready) this.checkIfReady()
  }
  openAssociateAddress () {
    this.setState({associateOpen: true})
  }

  checkIfReady () {
    const { shouldWaitForCalculations, hasCalculation, shouldWaitForBalances, hasBalances } = this.props

    DEBUG && console.group('Check if Ready')
    const done = m => {
      DEBUG && console.log('D0N3D0N3D0N3D0N3D0N3D0N3D0N3D0N3D0N3D0N3D0N3D0N3')
      DEBUG && console.log('D0N3D0N3D0N3D0N3D0N3D0N3D0N3D0N3D0N3D0N3D0N3D0N3')
      DEBUG && console.log('D0N3D0N3D0N3D0N3D0N3D0N3D0N3D0N3D0N3D0N3D0N3D0N3')
      DEBUG && console.log('D0N3D0N3D0N3D0N3D0N3D0N3D0N3D0N3D0N3D0N3D0N3D0N3')
      DEBUG && console.log('Set state to', true, 'for:', m)
      DEBUG && console.groupEnd()
      this.setState({ready: true})
    }

    const ignoreProps = 'singularPortfolio, location, params, user, hasUser, routeParams, route, router, routes, children'.split(', ')

    DEBUG && Object.keys(this.props)
      .filter(e => ignoreProps.indexOf(e) === -1)
      .map(e => console.log(`prop.${e} = `, this.props[e]))

    if (this.state.init) {
      const calcReady = (shouldWaitForCalculations && hasCalculation) || !shouldWaitForCalculations
      const balancesReady = (shouldWaitForBalances && hasBalances) || !shouldWaitForBalances
      if (calcReady && balancesReady) done('calcReady && balancesReady')
    }
    DEBUG && console.groupEnd()
  }

  onAssociateAddress (address) {
    let start = Date.now()
    const { portfolio, portfolioActions } = this.props
    const uid = this.props.user.profile.uid
    portfolioActions.associateAddressToPortfolio(portfolio, address)
      .then(_ => this.setState({associateOpen: false})) // close dialog
      .then(_ => portfolioActions.loadUserPortfolios(uid)) // reload portfolios
      .then(_ => {
        let end = Date.now()
        let duration = end - start
        const addAddressEvent = {
          address: address,
          uid: uid,
          duration: duration,
          keen: {
            timestamp: new Date().toISOString()
          }
        }
        recordEvent('add address to portfolio', addAddressEvent, function(err, res){
          if (err) {
            console.log('Address error')
          }
          else {
            console.log('Address added to profile!')
          }
        })
      })
  }

  deleteAddress (address, key) {
    const { portfolio, portfolioActions } = this.props
    portfolioActions.removeAddressFromPortfolio(portfolio, address, key)
      .then(_ => portfolioActions.loadUserPortfolios(this.props.user.profile.uid)) // reload portfolios
  }

  startPortfolio ({disablePortfolio = false, disableBalances = false} = {}) {
    const { portfolio, chartActions, balancesActions, addressList = [], tokens } = this.props
    console.log('starting!', portfolio)

    if (!addressList.length) {
      this.setState({
        alertOpen: true,
        alertTitle: 'No addresses associated',
        alertText: 'Associate addresses with this portfolio to begin calculations'
      })
    } else {
      !disableBalances && balancesActions.calcBalances(portfolio.portfolio.pid, addressList, tokens)
        // .then(result => this.associateIdentifiedTokens(result))
      !disablePortfolio && chartActions.calcPortfolio(portfolio.portfolio.pid, addressList, tokens)
    }
  }

  associateIdentifiedTokens (data) {
    const { portfolio, portfolioActions: { associateTokenToPortfolio } } = this.props
    const { balances, baseTokens } = data
    const portfolioTokens = this.getPortfolioTokens()
    if (!balances.length) return false

    const symbols = balances.map(e => e.title)
    const identifiedTokens = baseTokens.filter(e => symbols.indexOf(e.symbol) >= 0)
    const portfolioSymbols = portfolioTokens.map(e => e.symbol)

    const missingTokens = identifiedTokens.filter(e => portfolioSymbols.indexOf(e.symbol) === -1)

    missingTokens.map(t => {
      let token = Object.keys(t).filter(e => !!t[e]).reduce((acc, val) => Object.assign(acc, {[val]: t[val]}), {})
      associateTokenToPortfolio(portfolio.portfolio.pid, token)
        .then(result => portfolioActions.loadUserPortfolios(this.props.user.profile.uid))
    })
  }

  deleteToken (symbol) {
    const { portfolio, portfolioActions: { removeCustomToken } } = this.props
    removeCustomToken(portfolio, symbol)
      .then(result => {
        this.props.portfolioActions.loadUserPortfolios(this.props.user.profile.uid)
      })
  }

  onTokenAdded () {
    this.setState({showAddToken: false})
    this.props.portfolioActions.loadUserPortfolios(this.props.user.profile.uid)
    return true
  }

  render () {
    const { pid } = this.props.routeParams
    const { portfolio, addressList, processProgress, tokens, calculationError, process, balances, chartActions, balancesActions } = this.props
    const { hasCalculation, hasBalances, hasAddresses } = this.props
    const onboarding = !hasAddresses || (!hasBalances || !hasCalculation) || (processProgress && (processProgress > 0 && !process.completed))

    if (!portfolio || !portfolio.portfolio || !this.state.ready) return <Spinner>Loading...</Spinner>

    const calcs = _.cloneDeep(this.props.calculations)

    return (
      <div className={['portfolio', pid].join(' ')}>
        <PageContent>
          <header className='tested'>
            <PortfolioHead
              doBalances={e => this.startPortfolio({disablePortfolio: true})}
              doCalculate={e => this.startPortfolio()}
              portfolio={portfolio}
              processProgress={processProgress}
              calculationError={calculationError}
              process={process}
              addressList={addressList}
              chartActions={chartActions}
              balancesActions={balancesActions}
              isSingular={this.props.singularPortfolio}
            />
          </header>
          {onboarding && <multi className='onboarding'>
            { /* Check if (hasNoCalculation, notCalculating, hasNoAddresses) */ }
            {!hasAddresses && (
              <AssociateAddresses doAssociate={e => this.openAssociateAddress()} />
            )}

            { /* Check if (hasNoCalculation, notCalculating, hasAddresses) */ }
            {hasAddresses && !hasCalculation && !processProgress && (
              <FirstCalc
                doCalc={e => this.startPortfolio()}
              />
            )}

            { /* Check if (hasNoCalculation, notCalculating, hasAddresses) */ }
            {hasAddresses && !!processProgress && (
              <CalculatingPortfolio
                status={processProgress}
              />
            )}
          </multi>}
          <primary>
            {hasCalculation && (
              <Card className='tested'>
                <CardHeader
                  title='Balance'
                />
                <CardText>
                  <h3 className='md-display-2'>
                    {balances.data && balances.data.length && balances.data.reduce((acc, val) => acc + val.value, 0).toLocaleString(...currencyFormat)}
                  </h3>

                  {calcs && (
                    <PerformanceChart calculations={calcs} />
                  )}
                </CardText>
              </Card>
            )}

            {hasAddresses && addressList.length > 0 && (
              <Card className='addresses' style={{padding: 0}}>
                <CardHeader
                  className='title'
                  title='Associated Addresses'
                >
                  <div className='actions'>
                    <Button icon primary tooltipLabel='Add' onClick={e => this.openAssociateAddress()}>
                      <ContentAdd />
                    </Button>
                  </div>
                </CardHeader>
                <CardText className='card-table' style={{padding: 0}}>

                  {/* Begin Addresses List */}

                  {addressList.length > 0 && (
                    <DataTable
                      responsive={false}
                      plain>
                      <TableHeader>
                        <TableRow>
                          <TableColumn className='icon'>{/* Icon */}</TableColumn>
                          <TableColumn className='address'>Addresses</TableColumn>
                          <TableColumn className='actions'>{/* Actions */}</TableColumn>
                        </TableRow>
                      </TableHeader>
                      <TableBody>
                        {addressList.map(({address, type, key}) => {
                          return (
                            <TableRow key={key} autoAdjust={false}>
                              <TableColumn className='icon'>{type === 'eth' && <EthereumIcon size={28} />}</TableColumn>
                              <TableColumn className='address'>{address}</TableColumn>
                              <TableColumn className='actions'>
                                <Button
                                  flat tooltipLabel='Delete Address' onClick={e => this.deleteAddress(address, key)}><ActionDelete /></Button>
                              </TableColumn>
                            </TableRow>
                          )
                        })}
                      </TableBody>
                    </DataTable>
                  )}

                  {/* End Addresses List */}

                </CardText>
              </Card>
            )}
          </primary>
          <secondary>
            {hasBalances && balances && balances.data && !!balances.data.length && (
              <Card className='tokens'>

                <CardHeader
                  className='title'
                  title='Tokens Allocation'>
                  <div className='actions'>
                    {(!tokens || !tokens.length) && (
                      <Button icon primary tooltipLabel='Add' onClick={e => this.setState({showAddToken: true})}>
                        <ContentAdd />
                      </Button>
                    )}
                    {tokens && !!tokens.length && (
                      <Button icon primary tooltipLabel='Configure Custom Tokens' onClick={e => {
                        e.preventDefault()
                        this.setState({showCustomTokens: !this.state.showCustomTokens})
                      }}>
                        <ActionSettings />
                      </Button>
                    )}
                    <AddTokenDialog open={this.state.showAddToken} portfolio={portfolio} then={(...args) => this.onTokenAdded(...args)} />
                  </div>
                </CardHeader>

                {tokens && tokens.length && this.state.showCustomTokens && (
                  <div className='custom-tokens'>
                    <CardText className='details'>
                      <h3>Custom Tokens</h3>
                      <p>Here you can configure your custom tokens</p>
                    </CardText>
                    <CardText className='card-table' style={{padding: 0}}>
                      <DataTable
                        responsive={false}
                        plain>
                        <TableHeader>
                          <TableRow>
                            <TableColumn className='icon'>{/* Icon */}</TableColumn>
                            <TableColumn>Symbol</TableColumn>
                            <TableColumn>{/* Action */}</TableColumn>
                          </TableRow>
                        </TableHeader>
                        <TableBody>
                          {tokens.map(({symbol}, index) => {
                            return (
                              <TableRow key={index}>
                                <TableColumn className='icon'>{symbol === 'ETH' && <EthereumIcon size={28} />}</TableColumn>
                                <TableColumn>{symbol}</TableColumn>
                                <TableColumn numeric>
                                  <Button
                                    flat tooltipLabel='Remove Token' onClick={e => this.deleteToken(symbol)}><ActionDelete /></Button>
                                </TableColumn>
                              </TableRow>
                            )
                          })}
                        </TableBody>
                      </DataTable>
                    </CardText>
                    <CardText className='actions'>
                      <Button raised label='Add custom token' onClick={e => this.setState({showAddToken: true})} />
                    </CardText>
                    <hr />
                    <h4>Identified Tokens</h4>
                  </div>
                )}
                <CardText className='card-table' style={{padding: 0}}>
                  {balances && balances.data && balances.data.length && (
                  <DataTable
                    responsive={false}
                    plain>
                    <TableHeader>
                      <TableRow>
                        <TableColumn className='icon'>{/* Icon */}</TableColumn>
                        <TableColumn>Name</TableColumn>
                        <TableColumn>Value</TableColumn>
                      </TableRow>
                    </TableHeader>
                    <TableBody>
                      {balances.data.map(({title, amount, value}, index) => {
                        return (
                          <TableRow key={index}>
                            <TableColumn className='icon'>{title === 'ETH' && <EthereumIcon size={28} />}</TableColumn>
                            <TableColumn>{title}</TableColumn>
                            <TableColumn numeric>{value.toLocaleString(...currencyFormat)}</TableColumn>
                          </TableRow>
                        )
                      })}
                    </TableBody>
                  </DataTable>
                  )}
                </CardText>
              </Card>
            )}
            {/*
              <Paper zDepth={1}>
                <h4>Can't see your tokens here?</h4>
                <p>Use the custom token feature to add your token and track it here</p>
                <div className='actions'>
                  <Button raised label='Add custom token' primary />
                </div>
              </Paper>
            */}
          </secondary>
          {this.props.singularPortfolio && (<footer>
            <NewPortfolio />
          </footer>)}
        </PageContent>
        <AssociateDialog
          portfolio={this.props.portfolio}
          addressList={addressList}
          onSubmit={address => this.onAssociateAddress(address)}
          onClose={e => this.setState({associateOpen: false})}
          isOpen={this.state.associateOpen} />

        <AlertDialog
          onClose={e => this.setState({alertOpen: false})}
          visible={this.state.alertOpen}
          title={this.state.alertTitle}
          >
          <div>{this.state.alertText}</div>
        </AlertDialog>
      </div>
    )
  }
}

function mapStateToProps (state, ownProps) {
  const { pid } = ownProps.routeParams
  const { portfolios = [], userPortfolios } = state.portfolio
  const portfolio = portfolios.find(e => e.portfolio.pid === pid)

  const { addresses = {} } = (portfolio && portfolio.portfolio) || {}

  const addressList = Object.keys(addresses).map(key => ({...addresses[key], key}))

  const calculations = state.portfolio && state.portfolio.calculations ? state.portfolio.calculations[pid] : null
  const process = state.portfolio.process[pid]

  const { log = [] } = (process && process.started && process) || {}
  const progressLog = log.filter(l => l.type === 'PORTFOLIO_CALCULATION_UPDATE')
  const processProgress = progressLog && progressLog.length && progressLog[progressLog.length - 1].progress
  const calculationError = log.find(l => l.type === 'PORTFOLIO_CALCULATION_ERROR')

  const balances = (state.balances && state.balances.byPid && state.balances.byPid[pid]) || []

  // /// /// /// /// /// /// //

  const shouldWaitForCalculations = portfolio && !!portfolio.portfolio.lastCalculated
  const lastCalculated = portfolio && portfolio.portfolio.lastCalculated
  const hasCalculation = lastCalculated && !!calculations

  const shouldWaitForBalances = portfolio && !!portfolio.portfolio.lastBalances
  const lastBalances = portfolio && balances && balances.updatedOn
  const hasBalances = portfolio && balances && !!balances.updatedOn

  const hasAddresses = portfolio && addressList && !!addressList.length

  const { tokens } = (portfolio && portfolio.portfolio) || {}
  const tokenKeys = (tokens && Object.keys(tokens)) || []
  const tokensArray = tokenKeys.map(k => Object.assign({}, tokens[k]))

  return {
    user: state.user,
    singularPortfolio: userPortfolios.length === 1,
    portfolio,
    addressList,
    calculations,
    process,
    processProgress,
    calculationError,
    balances,
    tokens: tokensArray,

    shouldWaitForCalculations,
    hasCalculation,
    lastCalculated,
    shouldWaitForBalances,
    hasBalances,
    lastBalances,
    hasAddresses
  }
}

function mapDispatchToProps (dispatch) {
  return {
    balancesActions: bindActionCreators(balancesActions, dispatch),
    userActions: bindActionCreators(userActions, dispatch),
    portfolioActions: bindActionCreators(portfolioActions, dispatch),
    chartActions: bindActionCreators(chartActions, dispatch)
  }
}

export default connect(mapStateToProps, mapDispatchToProps)(Portfolio)

export const onRouteEnter = (nextState, replace) => {
  // done()
}
