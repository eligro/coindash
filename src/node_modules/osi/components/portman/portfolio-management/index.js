import React, { Component } from 'react'
import { bindActionCreators } from 'redux'
import { browserHistory } from 'react-router'
import { connect } from 'react-redux'
import * as portfolioActions from '../../../../../actions/portfolio.actions'
import * as balancesActions from '../../../../../actions/balances.actions'

import Paper from 'material-ui/Paper'

import './portfolio-management.css'

const DEBUG = false

class Wrap extends Component {
  constructor (props) {
    super(props)

    this.state = { }
  }

  shouldComponentUpdate (nextProps, nextState) {
    // What do we have?
    // - user
    // -- Portfolios
    // -- Portfolio
    // --- Calculations
    // --- Balances

    DEBUG && console.group('Should Update?')
    const done = m => {
      DEBUG && console.log('Updating due to:', m)
      DEBUG && console.log('---------------------------------------------')
      DEBUG && console.log('=============================================')
      DEBUG && console.log('---------------------------------------------')
      DEBUG && console.log('=============================================')
      DEBUG && console.log('---------------------------------------------')
      DEBUG && console.groupEnd()
      return true
    }

    const {
      user,
      portfoliosLoaded,
      currentPortfolio,
      currentBalances
    } = this.props
    const {
      user: nextUser,
      portfoliosLoaded: nextPortfoliosLoaded,
      currentPortfolio: nextCurrentPortfolio,
      currentBalances: nextCurrentBalances
    } = nextProps

    const ignoreProps = ['currentBalances', 'currentPortfolio', 'location', 'params', 'user', 'hasUser', 'routeParams', 'route', 'router', 'routes', 'children', 'userPortfoliosFetching']

    DEBUG && Object.keys(nextProps)
      .filter(e => ignoreProps.indexOf(e) === -1)
      .map(e => console.log(`prop.${e} = `, nextProps[e]))
    // User check - logged in change, and uid
    if (!user && nextUser) return done('!user && nextUser')
    if ((!nextUser || !nextUser.profile) && (user && user.profile)) return done('(!nextUser || !nextUser.profile) && (user && user.profile)')
    if (user && nextUser && user.profile && user.profile.uid !== nextUser.profile.uid) return done('user.profile.uid !== nextUser.profile.uid')

    // if PID changes
    if (currentPortfolio !== nextCurrentPortfolio) return done('currentPortfolio !== nextCurrentPortfolio')

    // If portfolios loaded
    if (!portfoliosLoaded && nextPortfoliosLoaded) return done('!portfoliosLoaded && nextPortfoliosLoaded')

    // If fetching status changes
    // if (userPortfoliosFetching !== nextUserPortfoliosFetching) return done('userPortfoliosFetching !== nextUserPortfoliosFetching')

    // If calculations updated
    if (!currentBalances && nextCurrentBalances) return done('userPortfoliosFetching !== nextUserPortfoliosFetching')
    if (currentBalances && currentBalances.updatedOn < nextCurrentBalances.updatedOn) return done('userPortfoliosFetching !== nextUserPortfoliosFetching')


    // If balances updated
    if (!currentBalances && nextCurrentBalances) return done('userPortfoliosFetching !== nextUserPortfoliosFetching')
    if (currentBalances && currentBalances.updatedOn < nextCurrentBalances.updatedOn) return done('userPortfoliosFetching !== nextUserPortfoliosFetching')



    DEBUG && console.info('didn\'t update')
    DEBUG && console.groupEnd()

    return false
  }

  componentDidMount (props) {
    this.fetchRelevantContent(props)
  }

  componentWillReceiveProps (nextProps) {
    this.fetchRelevantContent(nextProps)
    const { pid } = nextProps.params
    const { pathname } = nextProps.location

    if (pathname === '/portfolios' && !pid && nextProps && nextProps.userPortfolios && nextProps.userPortfolios.length === 1) {
      const pf = nextProps.userPortfolios[0]
      if (pid !== pf.portfolio.pid) {
        browserHistory.push(`/p/${pf.portfolio.pid}`)
      }
    }
  }

  fetchRelevantContent (props) {
    const { user, portfolio, portfolioActions, balancesActions } = props || {}

    if (!portfolioActions) return null

    const fiveMinutesAgoOrMore = input => Date.now() - (+input) >= 1000 * 5

    if (!props) return false

    // Load users portfolio if this is his first time here
    if (user && user.profile && !props.userPortfoliosFetching && (!props.portfoliosLoaded || fiveMinutesAgoOrMore(portfolio.lastUpdate))) {
      portfolioActions.loadUserPortfolios(user.profile.uid)
    }

    // If we have some basics about the portfolio
    if (props) {
      if (props.currentPortfolio) {
        // see if we have balances and fetchem if don't
        if (!props.currentBalances && !props.balancesLoaded) {
          balancesActions.fetchBalances(props.currentPortfolio)
            .then(result => {
              // console.info('result of balances:', result)
            })
        }
      }
    }
  }

  render () {
    const Children = () => this.props.children
    return (
      <Paper className='pm-wrap' zDepth={1} style={{borderRadius: 0}}>
        {false && (<div>
          <h3>Debug</h3>
          <pre>
            {JSON.stringify(this.props.nextProps, 1, 1)}
          </pre>
        </div>)}
        <Children />
      </Paper>
    )
  }
}

function mapStateToProps (state, ownProps) {
  const { pid } = ownProps.routeParams
  const { user, portfolio, balances } = state

  const currentPortfolio = portfolio && portfolio.portfolio
  const lastCalculated = currentPortfolio && currentPortfolio.lastCalculated
  const currentCalculation = pid && portfolio.calculations ? portfolio.calculations[pid] : null

  const portfoliosLoaded = !!(portfolio && portfolio.lastUpdate)

  const routePid = ownProps.params.pid
  const nextProps = {
    hasUser: !!(user && user.profile),
    userPortfoliosFetching: !!(portfolio && portfolio.userPortfoliosFetching),
    portfoliosLoaded,
    currentPortfolio: (portfolio && portfolio.hasUserPortfolios && (routePid || portfolio.activePortfolio || portfolio.userPortfolios[0])),
    lastCalculated,
    currentCalculation
  }

  if (nextProps.currentPortfolio) {
    nextProps['currentBalances'] = balances && balances.byPid && balances.byPid[nextProps.currentPortfolio]
  }

  return {
    ...nextProps,
    user: state.user,
    portfolio: state.portfolio,
    balances: state.balances && state.balances.byPid,
    userPortfolios: state.portfolio && state.portfolio.portfolios && state.portfolio.userPortfolios && state.portfolio.portfolios
      .filter(pf => state.portfolio.userPortfolios.indexOf(pf.portfolio.pid) !== -1)
  }
}

function mapDispatchToProps (dispatch) {
  return {
    portfolioActions: bindActionCreators(portfolioActions, dispatch),
    balancesActions: bindActionCreators(balancesActions, dispatch)
  }
}

export default connect(mapStateToProps, mapDispatchToProps)(Wrap)
