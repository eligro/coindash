import React, { Component } from 'react'
import { connect } from 'react-redux'
import { bindActionCreators } from 'redux'
import { browserHistory } from 'react-router'

import Tour from 'reactour'

import * as portfolioActions from '../../../../../../actions/portfolio.actions'
import * as coinActions from '../../../../../../actions/coins.actions'

import { Spinner } from 'osi/bits'
import PortfolioAvatar from 'osi/bits/portfolio-avatar'

import Balances from './balance'
import Benchmark from './benchmark'
import Tickers from './tickers'

import FlatButton from 'material-ui/FlatButton'
import Popover, {PopoverAnimationVertical} from 'material-ui/Popover'
import Menu from 'material-ui/Menu'
import MenuItem from 'material-ui/MenuItem'
import NavigationExpandMore from 'material-ui/svg-icons/navigation/expand-more'
import NavigationExpandLess from 'material-ui/svg-icons/navigation/expand-less'

import CreatePortfolio from 'osi/components/portman/parts/create-portfolio'
import MessageBlock from 'osi/components/portman/parts/message-block'

import './dashboard.css'

const steps = [
  {
    selector: '.sidenav a[href="/dashboard"]',
    content: <div>
      <h2>Your Dashboard</h2>
      <p>Here you can see how your portfolios behave at a glance, seeing all the information you need when you need it.</p>
    </div>
  },
  {
    selector: '.balance-card',
    content: <div>
      <h2>Balance and Tokens</h2>
      <ul>
        <li>Shows your current portfolio balance</li>
        <li>Lists the various tokens your portfolio is composed of</li>
      </ul>
      <p>In a single view you can check all the balances your portfolio is holding, this aggregated view will consider multiple ethereum (and later exchanges, bitcoin and more) accounts and will display each asset, its current balance and current USD value.
This is a great tool to have a quick snapshot of your holdings and their current market value.</p>
    </div>
  },
  {
    selector: '.benchmark-card',
    content: <div>
      <h2>Benchmark against the market</h2>
      <p>The main graph is the performance graph, displaying the aggregated changes (for each day) your portfolio did. It is benchmarked against the market to answer a question every investor should know the answer to.. ‘How am i doing against the market’
The basic idea is to understand if those various investment you did and various holding your have are under/ over performing the market.
For every single day the CoinDash graph will show how well the portfolio performed against the market on a % change. In the example above it is clearly show that for the most part the portfolio underperformed the market (eth in this case). This investor should have just keep his money in eth instead of investing in other assets.
</p>
    </div>
  },
  {
    selector: '.heighcharts-container',
    content: <div>
      <h2>Portfolio day-by-day balances</h2>
      <p>Keeping tight records on what trades happened in a portfolio is very hard and time consuming. The CoinDash dashboard enables to play back, day by day, the changes in the portfolio’s holdings and indicate the different trades and changes happening along the way.
It a great way to understand better what and how different changes and trades affected the portfolio.
</p>
    </div>
  },
  {
    selector: '.heighcharts-container',
    content: <div>
      <h2>Asset allocation</h2>
      <p>Changing the graph to the allocation tab will show a much clearer view of the different assets comprising the portfolio and how dominant is each and everyone of them.
It's a great way to quickly see how the portfolio is composed and make necessary changes based on that.</p>
    </div>
  },
]

class Dashboard extends Component {
  constructor (props) {
    super(props)

    this.state = {
      ready: false
    }
  }

  componentWillMount () {
    this.props.coinActions.loadFront()
    this.startPoll()
  }

  componentWillUnmount () {
    this.stopPoll()
  }

  startPoll () {
    this.timeout = setTimeout(() => {
      this.props.coinActions.loadFront()
      this.startPoll()
    }, 20000)
  }

  stopPoll () {
    clearTimeout(this.timeout)
  }

  // shouldComponentUpdate (nextProps, nextState) {
  //   console.log('check if componeont should update here:', nextProps, nextState)
  //   return true
  // }

  componentDidMount () {
    const { calculations, portfolio, portfolioActions, process } = this.props

    if (portfolio && portfolio.portfolio && portfolio.portfolio.lastCalculated) {
      let shouldIupdate = (!process || !process.fetching) && // not fetching, and
        (!calculations || !calculations.chartData || !calculations.dayDataByDate) // doesn't have calculations

      shouldIupdate
        ? portfolioActions.loadPortfolioCalculations(portfolio.portfolio.pid)
          .then(result => {
            this.setState({ready: true})
          })
        : this.setState({
          ready: true,
          hasPortfoflios: true
        })
    } else {
      this.setState({
        ready: true,
        hasPortfoflios: false
      })
    }
  }

  onChangePortfolio (pid) {
    this.props.portfolioActions.makePortfolioActive(pid)
    return true
  }
  closeTour () {
    this.setState({isTourOpen: false})
  }
  render () {
    const { user, userPortfolios, calculations, balances, portfolio } = this.props
    const { name } = user.profile || {}

    if (!this.state.ready) return <Spinner>Stand by...</Spinner>
    return (
      <div className='dashboard md-text'>
        <FlatButton label='start tour' onClick={e => this.setState({isTourOpen: true})} />
        {!userPortfolios.length && <WelcomeBlock name={name} />}
        {userPortfolios.length > 1 && <Portfolio
          onChange={(e, pid) => this.onChangePortfolio(pid)}
          portfolios={userPortfolios}
          portfolio={portfolio} />}

        <div className='stats'>
          <Balances balances={balances} onboarding={!userPortfolios.length} />
          <Benchmark calculations={calculations} balances={balances} onboarding={!userPortfolios.length} />
        </div>
        <div className='tickers'>
          <Tickers />
        </div>
        {false && (<pre>
          {JSON.stringify(userPortfolios, 1, 1)}
        </pre>)}

        <Tour
          className='demodash'
          steps={steps}
          isOpen={this.state.isTourOpen}
          onRequestClose={this.closeTour.bind(this)} />
      </div>
    )
  }
}

const WelcomeBlock = (props) => {
  const imgSrc = '/images/cryptos.png'
  return (
    <div className='welcome-block'>
      <MessageBlock className='welcome' media={imgSrc} actions={[
        <CreatePortfolio label='Create' key='create-portfolio' primary raised onCreate={(pf) => {
          browserHistory.push(`/p/${pf.portfolio.pid}`)
        }} />
      ]}>
        <h3>Get started with creating your first portfolio</h3>
        <p>
          Portfolios are your way to track the earnings and performance of your investments.
        </p>
        <p>
          Coindash portfolios support ETH and other ERC20 tokens. More to come soon...
        </p>

      </MessageBlock>
    </div>
  )
}

class Portfolio extends Component {
  constructor (props) {
    super(props)

    this.state = {
      open: false
    }
  }

  handleTouchTap (event) {
    // This prevents ghost click.
    event.preventDefault()

    this.setState({
      open: true,
      anchorEl: event.currentTarget
    })
  }

  handleRequestClose () {
    this.setState({
      open: false
    })
  }

  handleSelect (e, pid) {
    if (this.props.onChange(e, pid)) {
      this.setState({
        open: false
      })
    }
  }

  render () {
    const { portfolio, portfolios } = this.props
    const { pid } = portfolio.portfolio
    const items = portfolios.filter(pf => pf.portfolio !== pid)

    return (
      <div className='portfolio-handler'>
        <div className='wrap'>
          <span className='active-label'>Active Portfolio</span>
          <FlatButton
            onTouchTap={this.handleTouchTap.bind(this)}
            containerElement='div'
            className='current'
          >
            <PortfolioAvatar portfolio={portfolio} />
            <span>{portfolio.portfolio.name}</span>
            {this.state.open ? <NavigationExpandLess /> : <NavigationExpandMore />}
          </FlatButton>
          <Popover
            className='portfolio-selector'
            open={this.state.open}
            anchorEl={this.state.anchorEl}
            anchorOrigin={{horizontal: 'left', vertical: 'bottom'}}
            targetOrigin={{horizontal: 'left', vertical: 'top'}}
            onRequestClose={this.handleRequestClose.bind(this)}
            animation={PopoverAnimationVertical}
          >
            <Menu
              onChange={this.handleSelect.bind(this)}
              >
              {items.map(pf => (
                <MenuItem
                  value={pf.portfolio.pid}
                  className='portfolio-item'
                  key={pf.portfolio.pid}>
                  <PortfolioAvatar portfolio={pf} />

                  <span>{pf.portfolio.name}</span>
                </MenuItem>
              ))}
            </Menu>
          </Popover>
        </div>
      </div>
    )
  }
}

const getBalanceByPID = (pid, state) => {
  return state && pid && state.balances && state.balances.byPid &&
    state.balances.byPid.hasOwnProperty(pid) && state.balances.byPid[pid]
}

function mapStateToProps (state, ownProps) {
  const { portfolios, userPortfolios: userKeys } = state.portfolio
  const userPortfolios = portfolios.filter(pf => userKeys.indexOf(pf.portfolio.pid) !== -1)

  const pid = (state.portfolio && state.portfolio.activePortfolio) || userKeys[0]
  const portfolio = portfolios.find(pf => pf.portfolio.pid === pid)

  const calculations = state.portfolio && state.portfolio.calculations ? state.portfolio.calculations[pid] : null
  const process = state.portfolio.process[pid]

  const { log = [] } = (process && process.started && process) || {}
  const progressLog = log.filter(l => l.type === 'PORTFOLIO_CALCULATION_UPDATE')
  const processProgress = progressLog && progressLog.length && progressLog[progressLog.length - 1].progress
  const calculationError = log.find(l => l.type === 'PORTFOLIO_CALCULATION_ERROR')

  const balances = getBalanceByPID(pid, state)

  return {
    user: state.user,
    userPortfolios,
    portfolios,
    portfolio,
    calculations,
    process,
    processProgress,
    calculationError,
    balances
  }
}

function mapDispatchToProps (dispatch) {
  return {
    portfolioActions: bindActionCreators(portfolioActions, dispatch),
    coinActions: bindActionCreators(coinActions, dispatch)
  }
}

export default connect(mapStateToProps, mapDispatchToProps)(Dashboard)
