import React, { Component, PureComponent } from 'react'
import { connect } from 'react-redux'

import { bindActionCreators } from 'redux'
import { isEtherAddress } from '../../../../../../utils'

import * as userActions from '../../../../../../actions/user.actions'
import * as portfolioActions from '../../../../../../actions/portfolio.actions'
import * as chartActions from '../../../../../../actions/chart.actions'

import ActionDone from 'material-ui/svg-icons/action/done'
import TextField from 'react-md/lib/TextFields'

import { Avatar, ToolbarGroup, Toolbar, ToolbarTitle, IconButton } from 'material-ui'
import { Spinner } from 'osi/bits'
import PortfolioAvatar from 'osi/bits/portfolio-avatar'
import CircularProgress from 'material-ui/CircularProgress'
import AVPlay from 'material-ui/svg-icons/av/play-circle-filled'

import NavigationMoreVert from 'material-ui/svg-icons/navigation/more-vert'
import EditorModeEdit from 'material-ui/svg-icons/editor/mode-edit'

import './portfolio.css'
import WebFont from 'webfontloader'
import Button from 'react-md/lib/Buttons/Button'
import Card from 'react-md/lib/Cards/Card'
import CardTitle from 'react-md/lib/Cards/CardTitle'
import CardText from 'react-md/lib/Cards/CardText'
import CardActions from 'react-md/lib/Cards/CardActions'
import List from 'react-md/lib/Lists/List'
import ListItem from 'react-md/lib/Lists/ListItem'
import FontIcon from 'react-md/lib/FontIcons'
import Dialog from 'react-md/lib/Dialogs'

import DataTable from 'react-md/lib/DataTables/DataTable'
import TableHeader from 'react-md/lib/DataTables/TableHeader'
import TableBody from 'react-md/lib/DataTables/TableBody'
import TableRow from 'react-md/lib/DataTables/TableRow'
import TableColumn from 'react-md/lib/DataTables/TableColumn'
import TableCardHeader from 'react-md/lib/DataTables/TableCardHeader'

import EthereumIcon from 'osi/bits/svg-icons/network/ethereum'

import PerformanceChart from 'osi/components/portman/parts/charts/performance'

class Portfolio extends Component {
  constructor (props) {
    super(props)

    this.state = {
      associateOpen: false,
      alertOpen: false
    }
  }

  componentDidMount () {
    const { calculations, portfolio, portfolioActions, process } = this.props
    if (portfolio && portfolio.portfolio && portfolio.portfolio.lastCalculated) {
      let shouldIupdate = (!process || !process.fetching) && // not fetching, and
        (!calculations || !calculations.chartData || !calculations.dayDataByDate) // doesn't have calculations

      shouldIupdate && portfolioActions.loadPortfolioCalculations(portfolio)
    }
  }
  openAssociateAddress () {
    this.setState({associateOpen: true})
  }

  onAssociateAddress (address) {
    const { portfolio, portfolioActions } = this.props
    portfolioActions.associateAddressToPortfolio(portfolio, address)
      .then(_ => this.setState({associateOpen: false})) // close dialog
      .then(_ => portfolioActions.loadUserPortfolios(this.props.user.profile.uid)) // reload portfolios
  }

  startPortfolio () {
    const { portfolio, chartActions, addressList = [] } = this.props
    console.log('starting!', portfolio)

    if (!addressList.length) {
      this.setState({
        alertOpen: true,
        alertTitle: 'No addresses associated',
        alertText: 'Associate addresses with this portfolio to begin calculations'
      })
    } else {
      chartActions.calcPortfolio(portfolio.portfolio.pid, addressList)
    }

  }
  render () {
    const { pid } = this.props.routeParams
    const { portfolio, addressList, processProgress, calculationError, process } = this.props

    if (!portfolio || !portfolio.portfolio) return <Spinner>Loading...</Spinner>

    return (
      <div className={['portfolio', pid].join(' ')}>
        <div className='titles'>
          <PortfolioAvatar portfolio={portfolio} />
          <h2>{portfolio.portfolio.name}</h2>
          <span style={{flex: '1 1 auto'}} />

          <IconButton
            iconStyle={{}}
            style={{}}
          >
            <EditorModeEdit />
          </IconButton>

          {(!process || !process.started || calculationError || !processProgress || !(processProgress > 0 && processProgress < 100)) && (
            <IconButton
              iconStyle={{}}
              style={{}}
              onClick={e => this.startPortfolio()}
            >
              <AVPlay />
            </IconButton>
          )}
          {(!calculationError && process && process.started && processProgress && (processProgress > 0 && processProgress < 100)) && (
            <CircularProgress max={100} min={0} mode='determinate' value={processProgress} size={30} />
          )}

        </div>

        {false && <div className='indicators'>
          <StatCard title='Associated accounts' value={Math.floor(Math.random() * 100)} />
          <StatCard title='Assets' value={Math.floor(Math.random() * 100)} />
          <StatCard title='Commulative value' value={Math.floor(Math.random() * 100)} />
          <StatCard title='Followers' value={Math.floor(Math.random() * 100)} />
        </div>}

        {this.props.calculations && (
          <PerformanceChart calculations={this.props.calculations} />
        )}

        <hr />
        <Button raised label='Associated address with portfolio' onClick={e => this.openAssociateAddress()} />

        {addressList.length > 0 && (
          <div className='addresses'>
            <h3>Associated addresses</h3>
            <DataTable plain>
              <TableHeader>
                <TableRow>
                  <TableColumn colSpan='2'>Addresses</TableColumn>
                </TableRow>
              </TableHeader>
              <TableBody>
                {addressList.map(({address, type, key}) => {
                  return (
                    <TableRow key={key}>
                      <TableColumn>{type === 'eth' && <EthereumIcon size={28} />}</TableColumn>
                      <TableColumn>{address}</TableColumn>
                    </TableRow>
                  )
                })}
              </TableBody>
            </DataTable>
          </div>
        )}

        <AssociateDialog
          portfolio={this.props.portfolio}
          addressList={addressList}
          onSubmit={address => this.onAssociateAddress(address)}
          onClose={e => this.setState({associateOpen: false})}
          isOpen={this.state.associateOpen} />

        <AlertDialog
          onClose={e => this.setState({alertOpen: false})}
          visible={this.state.alertOpen}
          title={this.state.alertTitle}
          >
          <div>{this.state.alertText}</div>
        </AlertDialog>
      </div>
    )
  }
}

class AssociateDialog extends PureComponent {
  constructor (props) {
    super(props)

    this.state = {
      isAddress: false,
      addressExists: false,
      error: false
    }
  }

  addressUpdate () {
    const address = this.refs.address.getField().value
    const isAddress = isEtherAddress(address)

    const { addressList = [] } = this.props
    const addressExists = !!addressList.find(e => e.address === address)

    if (
        ((!isAddress && this.state.isAddress) || (isAddress && !this.state.isAddress)) ||
        ((addressExists && !this.state.addressExists) || (!addressExists && this.state.addressExists))
      ) {
      this.setState({isAddress, addressExists})
    }
  }

  onSubmit (e) {
    const address = this.refs.address.getField().value
    const { isAddress, addressExists } = this.state

    e.preventDefault()

    if (isAddress && !addressExists) {
      this.props.onSubmit(address)
    } else if (addressExists) {
      this.setState({error: {
        address,
        addressExists
      }})
    } else {
      this.setState({error: {
        address,
        isAddress
      }})
    }
  }
  render () {
    const { isOpen, onClose } = this.props
    const { error } = this.state
    const errorText = error && ((error.isAddress && 'Value is not a valid ethereum address') || (error.addressExists && 'Address already exists'))
    return (
      <Dialog
        id='associate-address'
        visible={isOpen}
        title='Associate address with portfolio'
        onHide={e => {
          this.setState({error: false, isAddress: false, addressExists: false})
          onClose(e)
        }}
        aria-labelledby='Associate account...'
        component='div'
        closeOnEsc
        actions={[{
          onClick: onClose,
          primary: !this.state.isAddress,
          label: 'Cancel'
        }, {
          onClick: e => this.onSubmit(e),
          primary: true,
          disabled: !this.state.isAddress,
          label: 'Submit'
        }]}
       >

        <p>Enter a valid Ethereum address:</p>
        <form onSubmit={e => this.onSubmit(e)} className='address'>
          <TextField
            id='address'
            ref='address'
            label='Account address'
            type='text'
            error={!!error}
            errorText={errorText}
            helpText='e.g. 0x71CF9f77F1...'
            onChange={e => this.addressUpdate(e)}
            rightIcon={this.state.isAddress ? <ActionDone size={28} /> : (<span>&nbsp;</span> || (false && <CircularProgress size={28} />))}
            className='md-cell md-cell--bottom' />
        </form>

      </Dialog>
    )
  }
}

class AlertDialog extends Component {
  render () {
    const Children = _ => this.props.children || <div>&nbsp;</div>
    return (
      <Dialog
        id='alert'
        visible={this.props.visible}
        title={this.props.title || 'Alert'}
        onHide={e => this.props.onClose(e)}
        actions={[{
          onClick: e => this.props.onClose(e),
          primary: true,
          label: 'Ok'
        }]}
      >
        <Children />
      </Dialog>
    )
  }
}

class StatCard extends Component {
  render () {
    return (
      <Card className='indicator-card'>
        <CardTitle title={this.props.title} />
        <CardText className='weather-block'>
          <h2 className='md-display-2 display-override'>{this.props.value}</h2>
        </CardText>
        {false && <CardActions className='md-divider-border md-divider-border--top'>
          <Button flat label='Full Report' />
        </CardActions>}
      </Card>
    )
  }
}

function mapStateToProps (state, ownProps) {
  const { pid } = ownProps.routeParams
  const { portfolios = [] } = state.portfolio
  const portfolio = portfolios.find(e => e.portfolio.pid === pid)

  const { addresses = {} } = (portfolio && portfolio.portfolio) || {}

  const addressList = Object.keys(addresses).map(key => ({...addresses[key], key}))

  const calculations = state.portfolio && state.portfolio.calculations ? state.portfolio.calculations[pid] : null
  const process = state.portfolio.process[pid]

  const { log = [] } = (process && process.started && process) || {}
  const progressLog = log.filter(l => l.type === 'PORTFOLIO_CALCULATION_UPDATE')
  const processProgress = progressLog && progressLog.length && progressLog[progressLog.length - 1].progress
  const calculationError = log.find(l => l.type === 'PORTFOLIO_CALCULATION_ERROR')

  return {
    user: state.user,
    portfolio,
    addressList,
    calculations,
    process,
    processProgress,
    calculationError
  }
}

function mapDispatchToProps (dispatch) {
  return {
    userActions: bindActionCreators(userActions, dispatch),
    portfolioActions: bindActionCreators(portfolioActions, dispatch),
    chartActions: bindActionCreators(chartActions, dispatch)
  }
}

export default connect(mapStateToProps, mapDispatchToProps)(Portfolio)

export const onRouteEnter = (nextState, replace) => {
  // done()
}
