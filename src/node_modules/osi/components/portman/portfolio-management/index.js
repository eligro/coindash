import React, { Component } from 'react'
import { bindActionCreators } from 'redux'
import { connect } from 'react-redux'
import * as portfolioActions from '../../../../../actions/portfolio.actions'
import * as balancesActions from '../../../../../actions/balances.actions'

import Paper from 'material-ui/Paper'

import './portfolio-management.css'

class Wrap extends Component {
  constructor (props) {
    super(props)

    this.state = { }
    console.log('::::::::::::::::::::::::::::::::::::=')
    console.log('::::::::::::::::::::::::::::::::::::=')
    console.log('::::::::::::::::::::::::::::::::::::=')
    console.log('::::::::::::::::::::::::::::::::::::=')
    console.log('Wrap Instanciated')
  }

  componentDidMount (props) {
    this.fetchRelevantContent(props)
    console.log('::===================================')
    console.log('=====================================')
    console.log('=====================================')
    console.log('=====================================')
    console.log('Wrap Mounted')
  }
  componentWillReceiveProps (nextProps) {
    this.fetchRelevantContent(nextProps)
  }

  shouldComponentUpdate (nextProps, nextState) {
    console.group('shouldComponentUpdate')
    console.info('this.props', this.props)
    console.info('nextProps', nextProps)
    console.info('this.state', this.state)
    console.info('nextState', nextState)
    const userConnected = nextProps.user && nextProps.user.loggedIn
    // if user connected, should we update? not yet, we want to load his portfolios

    userConnected && console.info('User connected')

    console.groupEnd()

    return true
  }

  fetchRelevantContent (props) {
    const { peek, user, portfolio, balances, userPortfolios, portfolioActions, balancesActions } = props || {}

    if (!portfolioActions) return null
    console.group('fetch relevant content')

    const fiveMinutesAgoOrMore = input => Date.now() - (+input) >= 1000 * 5

    if (!props) return false

    // Load users portfolio if this is his first time here
    if (!props.userPortfoliosFetching && (!props.portfoliosLoaded || fiveMinutesAgoOrMore(portfolio.lastUpdate))) {
      portfolioActions.loadUserPortfolios(user.profile.uid)
    }

    // If we have some basics about the portfolio
    if (props) {
      if (props.currentPortfolio) {
        if (!props.currentBalances && !props.balancesLoaded) {
          balancesActions.fetchBalances(props.currentPortfolio)
            .then(result => {
              console.info('result of balances:', result)
            })
        }
        // see if we have balances and fetchem if don't

        // if ((!currentBalances || (currentBalances && !currentBalances.fetching))) {
        // }
      }
    }



    console.info('portfolio./userPortfoliosFetching', portfolio.userPortfoliosFetching)
    if (false && peek && peek.hasUser) {
      console.log('Well load stuff here')
      portfolioActions.loadUserPortfolios(user.profile.uid)
        .then(result => {
          console.log('so yea, we have user portfolios', result)
        })
    }
    console.groupEnd()

    return ':)'
    if (user && user.profile) {
      if (!portfolio || (!userPortfolios.length && (!portfolio.userPortfoliosFetching || portfolio.hasUserPortfolios))) {
        portfolioActions.loadUserPortfolios(user.profile.uid)
      }

      const bKeys = Object.keys(balances || {})
      if (userPortfolios && (!bKeys || !bKeys.length)) {
        userPortfolios.map(pf => {
          const balance = balances && balances[pf.portfolio.pid]
          const { lastBalances } = pf.portfolio
          const { updatedOn, fetching, started, completed } = balance || {}
          if (lastBalances && !fetching && (!balance || updatedOn < lastBalances) && (!started || (started && completed))) {
            balancesActions.fetchBalances(pf.portfolio.pid)
          }
        })
      }
    }

    if (!portfolio || portfolio.userPortfoliosFetching) return null
    if (user && user.profile) {
      if (!portfolio || (!userPortfolios || !userPortfolios.length)) {
        if (!portfolio.userPortfolios.length && portfolio.hasUserPortfolios) {
          portfolioActions.loadUserPortfolios(user.profile.uid)
        }
      }
    } else {
    }
  }

  render () {
    const Children = () => this.props.children
    return (
      <Paper className='pm-wrap' zDepth={1}>
        {false && (<div>
          <h3>Debug</h3>
          <pre>
            {JSON.stringify(this.props.nextProps, 1, 1)}
          </pre>
        </div>)}
        <Children />
      </Paper>
    )
  }
}

function mapStateToProps (state, ownProps) {
  const { user, portfolio, balances } = state
  const nextProps = {
    hasUser: !!(user && user.profile),
    userPortfoliosFetching: !!(portfolio && portfolio.userPortfoliosFetching),
    portfoliosLoaded: !!(portfolio && portfolio.lastUpdate),

    currentPortfolio: (portfolio && portfolio.hasUserPortfolios && (portfolio.currentPortfolio || portfolio.userPortfolios[0]))
  }

  if (nextProps.currentPortfolio) {
    nextProps['currentBalances'] = balances && balances.byPid && balances.byPid[nextProps.currentPortfolio]
    nextProps['balancesLoaded'] = !!(nextProps.currentBalances && nextProps.currentBalances.lastUpdate)
  }

  return {
    ...nextProps,
    user: state.user,
    portfolio: state.portfolio,
    balances: state.balances && state.balances.byPid,
    userPortfolios: state.portfolio && state.portfolio.portfolios && state.portfolio.userPortfolios && state.portfolio.portfolios
      .filter(pf => state.portfolio.userPortfolios.indexOf(pf.portfolio.pid) !== -1)
  }
}

function mapDispatchToProps (dispatch) {
  return {
    portfolioActions: bindActionCreators(portfolioActions, dispatch),
    balancesActions: bindActionCreators(balancesActions, dispatch)
  }
}

export default connect(mapStateToProps, mapDispatchToProps)(Wrap)
