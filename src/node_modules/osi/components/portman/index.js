import firebase from '../../../../utils/database.react.js'
import { getCurrentUser } from 'osi/auth'
import { usersPath } from 'osi/user'

export const portfoliosPath = 'portfolios'
const db = firebase.database()
const portfoliosRef = db.ref(portfoliosPath)
const pidsPath = 'pids'
const tasksPath = 'tasks'
const calculationsPath = 'calculations'
const balancesPath = 'balances'

// console.log('firebase:', firebase)
const PUSH_CHARS = '-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz'

export function decodeFirebaseTimestamp (id) {
  id = id.substring(0, 8)
  var timestamp = 0
  for (var i = 0; i < id.length; i++) {
    var c = id.charAt(i)
    timestamp = timestamp * 64 + PUSH_CHARS.indexOf(c)
  }
  return timestamp
}

export const createPortfolio = ({name, uid, description}) => {
  const { TIMESTAMP } = firebase.database.ServerValue
  let newPfid = portfoliosRef.push().key
  let newUserKey = db.ref(`${usersPath}/${uid}/portfolios`).push().key
  let pid = (Math.random() * 10000000000).toString(36).substr(2).split('.').reverse().join('')
  // let newPIDKey = db.ref('pids').child(pid)

  // create a portfolio in `portfolios` and link it to the user at `users/$uid/portfolios`
  let updates = {}
  let portfolio = {
    createdOn: TIMESTAMP,
    pid,
    name,
    owner: uid,
    description
  }
  updates[`${usersPath}/${uid}/portfolios/${newUserKey}`] = newPfid
  updates[`${usersPath}/${uid}/lastUpdate`] = TIMESTAMP
  updates[`${portfoliosPath}/${newPfid}`] = {...portfolio}

  return db.ref().update(updates)
    .then(_ => ({[`${pidsPath}/${pid}`]: newPfid})) // Create short PID for Portfolio
    .then(r => db.ref().update(r)) // Make the update
    .then(_ => ({ // Return a valid Portfolio object
      pfid: newPfid,
      userKey: newUserKey,
      portfolio
    }))
}

export const getPortfolio = pfid => {
  return portfoliosRef.child(pfid).once('value')
    .then(snp => snp.val())
}

export const getUserPortfolios = (uid, {fromIndex, limit = 50} = {}) => {
  let userPortfoliosRef = db.ref(`${usersPath}/${uid}/portfolios`)

  return new Promise((resolve, reject) => {
    let children = []
    userPortfoliosRef.limitToFirst(limit).once('value', snp => {
      // console.info('snapshot:', snp)
      snp.forEach(csnp => { children.push({key: csnp.key, pfid: csnp.val()}) })
      // console.log('children by now?', children)

      let promises = children.map(
        ({pfid, key}) => getPortfolio(pfid)
          .then(pf => {
            // console.log('result of get portfolio:', pf)
            return {
              pfid,
              portfolio: pf,
              userKey: key
            }
          })
      )

      Promise.all(promises)
        .then(portfolios => {

          resolve(portfolios.filter(pf => pf.portfolio))
        })

      // resolve(children)
    })
  })
}

export const associateAddressWithPortfolio = (portfolio, newAddress) => {
  const { pfid } = portfolio
  console.log('add to database')
  let pfRef = db.ref(portfoliosPath).child(pfid)
  let newAKey = pfRef.child('addresses').push().key
  let newTKey = db.ref(`${tasksPath}/${usersPath}/${portfolio.portfolio.owner}`).child('tasks').push().key

  const updates = {}
  updates[`${portfoliosPath}/${pfid}/addresses/${newAKey}`] = {
    address: newAddress,
    type: 'eth'
  }
  // updates[`${tasksPath}/${usersPath}/${portfolio.portfolio.owner}/tasks/${newTKey}`] = {
  //   createdOn: firebase.database.ServerValue.TIMESTAMP,
  //   category: 'portfolio',
  //   type: 'address',
  //   address: newAddress,
  //   pfid
  // }
  console.log('updates:', updates)
  return db.ref().update(updates)
    .then(_ => {
      console.log('updates successful')
      return true
    })
}

export const updatePortfolioCalculations = (pid, data) => {
  const { TIMESTAMP } = firebase.database.ServerValue

  const portfolioAggDelta = data && data.portfolio.map(i => [ i.timestamp * 1000, i.aggregatedDelta ])

  let dayDataByDate = {}
  data && data.portfolio.forEach(function (val) {
    dayDataByDate[ val.timestamp * 1000 ] = val
  })

  const btcAggDelta = data && data.market.map(i => [i.timestamp * 1000, i.aggregatedDelta])

  const parsed = {
    chartData: {
      btcAggDelta,
      portfolioAggDelta
    },
    dayDataByDate
  }

  return getPFIDByPID(pid).then(pfid => {
    const updates = {}
    updates[`${calculationsPath}/${pfid}`] = {
      // data: JSON.stringify(data),
      parsed: JSON.stringify(parsed),
      timestamp: TIMESTAMP
    }
    updates[`${portfoliosPath}/${pfid}/lastCalculated`] = TIMESTAMP
    return db.ref().update(updates)
      .then(_ => {
        console.log('calculations saved')
        return true
      })
  })
}

export const getPortfolioCalculations = pfid => {
  return db.ref(calculationsPath).child(pfid)
    .once('value')
    .then(snp => {
      const data = snp.val()
      return data && JSON.parse(data.parsed)
    })
}

const _pidCache = {}
export const getPFIDByPID = (pid) => {
  return new Promise((resolve, reject) => {
    const cached = _pidCache[pid]

    if (cached) resolve(cached)
    else {
      const pidRef = db.ref(pidsPath).child(pid)
      pidRef.once('value')
        .then(snp => {
          let val = snp.val()
          _pidCache[pid] = val
          resolve(val)
        })
    }
  })
}

export const updatePortfolioBalances = (pid, data) => {
  const { TIMESTAMP } = firebase.database.ServerValue

  return getPFIDByPID(pid).then(pfid => {
    const updates = {}
    updates[`${balancesPath}/${pfid}`] = {
      data: data,
      updatedOn: TIMESTAMP
    }
    updates[`${portfoliosPath}/${pfid}/lastBalances`] = TIMESTAMP
    return db.ref().update(updates)
      .then(_ => {
        return updates[`${balancesPath}/${pfid}`]
      })
  })
}

export const getPortfolioBalances = pfid => {
  return db.ref(balancesPath).child(pfid).once('value')
    .then(snp => {
      const data = snp.val()
      return data
    })
}

export const getPortfolios = ({fromIndex, limit = 50} = {}) => {
  let portfoliosRef = db.ref(portfoliosPath)

  return new Promise((resolve, reject) => {
    let children = []
    portfoliosRef.limitToFirst(limit).once('value', snp => {
      snp.forEach(csnp => {
        children.push({pfid: csnp.key, ...csnp.val()})
      })

      resolve(children)
    })
  })
}

export const deletePortfolio = pf => {
  const { pfid, portfolio, userKey } = pf
  const { pid, owner } = portfolio
  return new Promise((resolve, reject) => {
    const promises = []
    const pfRef = db.ref(portfoliosPath).child(pfid).remove()
    const pidRef = db.ref(pidsPath).child(pid).remove()
    const calcRef = db.ref(calculationsPath).child(pfid).remove()
    const balsRef = db.ref(balancesPath).child(pfid).remove()
    const userRef = db.ref(usersPath).child(owner).child(portfoliosPath).child(userKey).remove()
    promises.push(pfRef, pidRef, calcRef, balsRef, userRef)

    Promise.all(promises)
      .then(resolve)
  })
}
