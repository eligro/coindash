import React, { Component } from 'react'
import { connect } from 'react-redux'
import { bindActionCreators } from 'redux'
import { browserHistory } from 'react-router'


import * as portfolioActions from '../../../../../../actions/portfolio.actions'
import * as coinActions from '../../../../../../actions/coins.actions'
import * as userActions from '../../../../../../actions/user.actions'

import { Spinner } from 'osi/bits'
import PortfolioAvatar from 'osi/bits/portfolio-avatar'

import Balances from './balance'
import Benchmark from './benchmark'
import Tickers from './tickers'

import FlatButton from 'material-ui/FlatButton'
import Popover, {PopoverAnimationVertical} from 'material-ui/Popover'
import Menu from 'material-ui/Menu'
import MenuItem from 'material-ui/MenuItem'
import NavigationExpandMore from 'material-ui/svg-icons/navigation/expand-more'
import NavigationExpandLess from 'material-ui/svg-icons/navigation/expand-less'

import CreatePortfolio from 'osi/components/portman/parts/create-portfolio'
import MessageBlock from 'osi/components/portman/parts/message-block'

import TourGuide from './tourguide'

import './dashboard.css'

class Dashboard extends Component {
  constructor (props) {
    super(props)

    this.state = {
      ready: false
    }
  }

  componentWillMount () {
    this.props.coinActions.loadFront()
    this.startPoll()
  }

  componentWillUnmount () {
    this.stopPoll()
  }

  startPoll () {
    this.timeout = setTimeout(() => {
      this.props.coinActions.loadFront()
      this.startPoll()
    }, 20000)
  }

  stopPoll () {
    clearTimeout(this.timeout)
  }

  // shouldComponentUpdate (nextProps, nextState) {
  //   console.log('check if componeont should update here:', nextProps, nextState)
  //   return true
  // }

  componentDidMount () {
    const { calculations, portfolio, portfolioActions, process, userProps } = this.props

    if (portfolio && portfolio.portfolio && portfolio.portfolio.lastCalculated) {
      let shouldIupdate = (!process || !process.fetching) && // not fetching, and
        (!calculations || !calculations.chartData || !calculations.dayDataByDate) // doesn't have calculations

      shouldIupdate
        ? portfolioActions.loadPortfolioCalculations(portfolio.portfolio.pid)
          .then(result => {
            this.setState({ready: true})
          })
        :
          this.setState({
            ready: true,
            hasPortfoflios: true
          })
          // if (userProps && userProps.takenTour == null) {
          //   this.props.userActions.activateTour()
          //   this.setState({isTourOpen: true})
          // } else if (userProps && !userProps.takenTour) {
          //   this.setState({isTourOpen: true})
          // }
    } else {
      this.setState({
        ready: true,
        hasPortfoflios: false
      })
    }
  }

  onChangePortfolio (pid) {
    this.props.portfolioActions.makePortfolioActive(pid)
    return true
  }
  closeTour () {
    const { uid } = this.props.user.profile
    this.props.userActions.dismissTour(uid)
    this.setState({isTourOpen: false})
  }

  onTourStep (stepNum) {
    console.log('what is stepnum?', stepNum)
  }

  render () {
    const { user, userPortfolios, calculations, balances, portfolio } = this.props
    const { name } = user.profile || {}

    if (!this.state.ready) return <Spinner>Stand by...</Spinner>
    return (
      <div className='dashboard md-text'>
        {!userPortfolios.length && <WelcomeBlock name={name} />}
        {userPortfolios.length > 1 && <Portfolio
          onChange={(e, pid) => this.onChangePortfolio(pid)}
          portfolios={userPortfolios}
          portfolio={portfolio} />}

        <div className='stats'>
          <Balances balances={balances} onboarding={!userPortfolios.length} />
          <Benchmark calculations={calculations} balances={balances} onboarding={!userPortfolios.length} />
        </div>
        <div className='tickers'>
          <Tickers />
        </div>
        {false && (<pre>
          {JSON.stringify(userPortfolios, 1, 1)}
        </pre>)}

        {calculations && <TourGuide onStep={this.onTourStep.bind(this)} lastCalculated={this.props.portfolio && this.props.portfolio.portfolio.lastCalculated} />}
      </div>
    )
  }
}

const WelcomeBlock = (props) => {
  const imgSrc = '/images/cryptos.png'
  return (
    <div className='welcome-block'>
      <MessageBlock className='welcome' media={imgSrc} actions={[
        <CreatePortfolio label='Create' key='create-portfolio' primary raised onCreate={(pf) => {
          browserHistory.push(`/p/${pf.portfolio.pid}`)
        }} />
      ]}>
        <h3>Get started with creating your first portfolio</h3>
        <p>
          Portfolios are your way to track the earnings and performance of your investments.
        </p>
        <p>
          Coindash portfolios support ETH and other ERC20 tokens. More to come soon...
        </p>

      </MessageBlock>
    </div>
  )
}

class Portfolio extends Component {
  constructor (props) {
    super(props)

    this.state = {
      open: false
    }
  }

  handleTouchTap (event) {
    // This prevents ghost click.
    event.preventDefault()

    this.setState({
      open: true,
      anchorEl: event.currentTarget
    })
  }

  handleRequestClose () {
    this.setState({
      open: false
    })
  }

  handleSelect (e, pid) {
    if (this.props.onChange(e, pid)) {
      this.setState({
        open: false
      })
    }
  }

  render () {
    const { portfolio, portfolios } = this.props
    const { pid } = portfolio.portfolio
    const items = portfolios.filter(pf => pf.portfolio !== pid)

    return (
      <div className='portfolio-handler'>
        <div className='wrap'>
          <span className='active-label'>Active Portfolio</span>
          <FlatButton
            onTouchTap={this.handleTouchTap.bind(this)}
            containerElement='div'
            className='current'
          >
            <PortfolioAvatar portfolio={portfolio} />
            <span>{portfolio.portfolio.name}</span>
            {this.state.open ? <NavigationExpandLess /> : <NavigationExpandMore />}
          </FlatButton>
          <Popover
            className='portfolio-selector'
            open={this.state.open}
            anchorEl={this.state.anchorEl}
            anchorOrigin={{horizontal: 'left', vertical: 'bottom'}}
            targetOrigin={{horizontal: 'left', vertical: 'top'}}
            onRequestClose={this.handleRequestClose.bind(this)}
            animation={PopoverAnimationVertical}
          >
            <Menu
              onChange={this.handleSelect.bind(this)}
              >
              {items.map(pf => (
                <MenuItem
                  value={pf.portfolio.pid}
                  className='portfolio-item'
                  key={pf.portfolio.pid}>
                  <PortfolioAvatar portfolio={pf} />

                  <span>{pf.portfolio.name}</span>
                </MenuItem>
              ))}
            </Menu>
          </Popover>
        </div>
      </div>
    )
  }
}

const getBalanceByPID = (pid, state) => {
  return state && pid && state.balances && state.balances.byPid &&
    state.balances.byPid.hasOwnProperty(pid) && state.balances.byPid[pid]
}

function mapStateToProps (state, ownProps) {
  const { portfolios, userPortfolios: userKeys } = state.portfolio
  const userPortfolios = portfolios.filter(pf => userKeys.indexOf(pf.portfolio.pid) !== -1)

  const pid = (state.portfolio && state.portfolio.activePortfolio) || userKeys[0]
  const portfolio = portfolios.find(pf => pf.portfolio.pid === pid)

  const calculations = state.portfolio && state.portfolio.calculations ? state.portfolio.calculations[pid] : null
  const process = state.portfolio.process[pid]

  const { log = [] } = (process && process.started && process) || {}
  const progressLog = log.filter(l => l.type === 'PORTFOLIO_CALCULATION_UPDATE')
  const processProgress = progressLog && progressLog.length && progressLog[progressLog.length - 1].progress
  const calculationError = log.find(l => l.type === 'PORTFOLIO_CALCULATION_ERROR')

  const balances = getBalanceByPID(pid, state)

  return {
    user: state.user,
    userPortfolios,
    portfolios,
    portfolio,
    calculations,
    process,
    processProgress,
    calculationError,
    balances,
    userProps: state.user && state.user.properties
  }
}

function mapDispatchToProps (dispatch) {
  return {
    portfolioActions: bindActionCreators(portfolioActions, dispatch),
    coinActions: bindActionCreators(coinActions, dispatch)
  }
}

export default connect(mapStateToProps, mapDispatchToProps)(Dashboard)
