import firebase from '../../../../utils/database.react.js'
import { usersPath } from 'osi/user'

export const portfoliosPath = 'portfolios'
const db = firebase.database()
const portfoliosRef = db.ref(portfoliosPath)
const pidsPath = 'pids'
const calculationsPath = 'calculations'
const balancesPath = 'balances'
const PUSH_CHARS = '-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz'
const _pidCache = {}

export const getPFIDByPID = (pid) => {
  return new Promise((resolve, reject) => {
    const cached = _pidCache[pid]

    if (cached) resolve(cached)
    else {
      const pidRef = db.ref(pidsPath).child(pid)
      pidRef.once('value')
        .then(snp => {
          let val = snp.val()
          _pidCache[pid] = val
          resolve(val)
        })
    }
  })
}

export function decodeFirebaseTimestamp (id) {
  id = id.substring(0, 8)
  var timestamp = 0
  for (var i = 0; i < id.length; i++) {
    var c = id.charAt(i)
    timestamp = timestamp * 64 + PUSH_CHARS.indexOf(c)
  }
  return timestamp
}

export const createPortfolio = ({name, uid, description}) => {
  const { TIMESTAMP } = firebase.database.ServerValue
  let newPfid = portfoliosRef.push().key
  let newUserKey = db.ref(`${usersPath}/${uid}/portfolios`).push().key
  let pid = (Math.random() * 10000000000).toString(36).substr(2).split('.').reverse().join('')
  // let newPIDKey = db.ref('pids').child(pid)

  // create a portfolio in `portfolios` and link it to the user at `users/$uid/portfolios`
  let updates = {}
  let portfolio = {
    createdOn: TIMESTAMP,
    pid,
    name,
    owner: uid,
    description
  }
  updates[`${usersPath}/${uid}/portfolios/${newUserKey}`] = newPfid
  updates[`${usersPath}/${uid}/lastUpdate`] = TIMESTAMP
  updates[`${portfoliosPath}/${newPfid}`] = {...portfolio}

  return db.ref().update(updates)
    .then(_ => ({[`${pidsPath}/${pid}`]: newPfid})) // Create short PID for Portfolio
    .then(r => db.ref().update(r)) // Make the update
    .then(_ => ({ // Return a valid Portfolio object
      pfid: newPfid,
      userKey: newUserKey,
      portfolio
    }))
}

export const getPortfolio = pfid => {
  return portfoliosRef.child(pfid).once('value')
    .then(snp => snp.val())
}

export const getUserPortfolios = (uid, {fromIndex, limit = 50} = {}) => {
  let userPortfoliosRef = db.ref(`${usersPath}/${uid}/portfolios`)

  return new Promise((resolve, reject) => {
    let children = []
    userPortfoliosRef.limitToFirst(limit).once('value', snp => {
      // console.info('snapshot:', snp)
      snp.forEach(csnp => { children.push({key: csnp.key, pfid: csnp.val()}) })
      // console.log('children by now?', children)

      let promises = children.map(
        ({pfid, key}) => getPortfolio(pfid)
          .then(pf => {
            // console.log('result of get portfolio:', pf)
            return {
              pfid,
              portfolio: pf,
              userKey: key
            }
          })
      )

      Promise.all(promises)
        .then(portfolios => {

          resolve(portfolios.filter(pf => pf.portfolio))
        })

      // resolve(children)
    })
  })
}

export const associateAddressWithPortfolio = (portfolio, newAddress) => {
  const { pfid } = portfolio
  let pfRef = db.ref(portfoliosPath).child(pfid)
  let newAKey = pfRef.child('addresses').push().key

  const updates = {}
  updates[`${portfoliosPath}/${pfid}/addresses/${newAKey}`] = {
    address: newAddress,
    type: 'eth'
  }
  return db.ref().update(updates)
    .then(_ => {
      return true
    })
}

export const updatePortfolioCalculations = (pid, data) => {
  const { TIMESTAMP } = firebase.database.ServerValue

  const portfolioAggDelta = data && data.portfolio.map(i => [ i.timestamp * 1000, i.aggregatedDelta ])

  let dayDataByDate = {}
  data && data.portfolio.forEach(function (val) {
    dayDataByDate[ val.timestamp * 1000 ] = {
      dayFiatValue: val.dayFiatValue,
      balances: val.balances
    }
  })

  const btcAggDelta = data && data.market.map(i => [i.timestamp * 1000, i.aggregatedDelta])

  const parsed = {
    chartData: {
      btcAggDelta,
      portfolioAggDelta
    },
    dayDataByDate
  }

  return getPFIDByPID(pid).then(pfid => {
    const updates = {}
    updates[`${calculationsPath}/${pfid}`] = {
      // data: JSON.stringify(data),
      parsed: JSON.stringify(parsed),
      timestamp: TIMESTAMP
    }
    updates[`${portfoliosPath}/${pfid}/lastCalculated`] = TIMESTAMP
    return db.ref().update(updates)
      .then(_ => {
        console.log('calculations saved')
        return true
      })
  })
}

export const getPortfolioCalculations = pid => {
  return getPFIDByPID(pid).then(pfid =>
    db.ref(calculationsPath).child(pfid)
      .once('value')
      .then(snp => {
        const data = snp.val()
        return data && JSON.parse(data.parsed)
      })
  )
}


export const updatePortfolioBalances = (pid, data) => {
  const { TIMESTAMP } = firebase.database.ServerValue

  return getPFIDByPID(pid).then(pfid => {
    const updates = {}
    updates[`${balancesPath}/${pfid}`] = {
      data: data,
      updatedOn: TIMESTAMP
    }
    updates[`${portfoliosPath}/${pfid}/lastBalances`] = TIMESTAMP
    return db.ref().update(updates)
      .then(_ => {
        return updates[`${balancesPath}/${pfid}`]
      })
  })
}

export const getPortfolioBalances = pfid => {
  return db.ref(balancesPath).child(pfid).once('value')
    .then(snp => {
      const data = snp.val()
      return data
    })
}

export const getPortfolios = ({fromIndex, limit = 50} = {}) => {
  let portfoliosRef = db.ref(portfoliosPath)

  return new Promise((resolve, reject) => {
    let children = []
    portfoliosRef.limitToFirst(limit).once('value', snp => {
      snp.forEach(csnp => {
        children.push({pfid: csnp.key, ...csnp.val()})
      })

      resolve(children)
    })
  })
}

export const deletePortfolio = pf => {
  const { pfid, portfolio, userKey } = pf
  const { pid, owner } = portfolio
  return new Promise((resolve, reject) => {
    const promises = []
    const pidRef = db.ref(pidsPath).child(pid).remove()
    const calcRef = db.ref(calculationsPath).child(pfid).remove()
    const balsRef = db.ref(balancesPath).child(pfid).remove()
    const userRef = db.ref(usersPath).child(owner).child(portfoliosPath).child(userKey).remove()
    const pfRef = db.ref(portfoliosPath).child(pfid).remove()
    promises.push(pfRef, pidRef, calcRef, balsRef, userRef)

    Promise.all(promises)
      .then(resolve)
  })
}

export const deletePortfolioAddress = (pf, address, addressKey) => {
  const { pfid } = pf
  // TODO - removed unused `userKey`, `portfolio` and `owner` vars.
  // Do we have check in place to ensure other users can't delete portfolios?
  return db.ref(portfoliosPath).child(pfid).child('addresses').child(addressKey).remove()
}


export const associateTokenWithPortfolio = (pid, token) => {
  const { TIMESTAMP } = firebase.database.ServerValue
  const keyProps = 'contractAddress, customContract, decimal, ico_address, ico_initial_price_usd, symbol, ico_address'.split(', ')

  const tokenFixed = Object.keys(token).filter(e => keyProps.indexOf(e) !== -1).reduce((acc, val) => Object.assign(acc, {[val]: token[val]}), {})

  return getPFIDByPID(pid)
    .then(pfid => {
      let pfRef = db.ref(portfoliosPath).child(pfid)
      let newTKey = pfRef.child('tokens').push().key

      const updates = {}
      updates[`${portfoliosPath}/${pfid}/tokens/${newTKey}`] = Object.assign({}, tokenFixed, {
        addedOn: TIMESTAMP
      })
      return db.ref().update(updates)
        .then(result => {
          console.log('token added', result)
          return true
        })
    })
}

export const deleteCustomToken = (pf, symbol) => {
  const { tokens } = pf.portfolio
  const tokenKey = Object.keys(tokens).find(k => tokens[k].symbol === symbol)
  return db.ref(portfoliosPath).child(pf.pfid).child('tokens').child(tokenKey).remove()
}
