import React, { Component } from 'react'
import { bindActionCreators } from 'redux'
import { Link, browserHistory } from 'react-router'
import { connect } from 'react-redux'
import * as portfolioActions from '../../../../../actions/portfolio.actions'
import * as balancesActions from '../../../../../actions/balances.actions'

import Paper from 'material-ui/Paper'

import './portfolio-management.css'

class Wrap extends Component {
  constructor (props) {
    super(props)

    this.state = { }
  }

  shouldComponentUpdate (nextProps, nextState) {
    const newUser = (nextProps.user && this.props.user) && (nextProps.user.email !== this.props.user.email)
    const differentPortfolio = nextProps.portfolio.activePortfolio !== this.props.portfolio.activePortfolio
    if (newUser) return true
    if (differentPortfolio) return true
    if (!nextProps.userPortfoliosFetching && this.props.userPortfoliosFetching) return true
    if (nextProps.currentBalances && !this.props.currentBalances) {
      return true
    } else if (this.props.currentBalances && nextProps.currentBalances && !(nextProps.currentBalances.fetching === this.props.currentBalances.fetching)) return true

    return false
  }

  componentDidMount (props) {
    this.fetchRelevantContent(props)
  }

  componentWillReceiveProps (nextProps) {
    this.fetchRelevantContent(nextProps)
    const { pid } = nextProps.params
    const { pathname } = nextProps.location

    if (pathname === '/portfolios' && !pid && nextProps && nextProps.userPortfolios && nextProps.userPortfolios.length === 1) {
      const pf = nextProps.userPortfolios[0]
      if (pid !== pf.portfolio.pid) {
        browserHistory.push(`/p/${pf.portfolio.pid}`)
      }
    }
  }

  fetchRelevantContent (props) {
    const { peek, user, portfolio, balances, userPortfolios, portfolioActions, balancesActions } = props || {}

    if (!portfolioActions) return null

    const fiveMinutesAgoOrMore = input => Date.now() - (+input) >= 1000 * 5

    if (!props) return false

    // Load users portfolio if this is his first time here
    if (!props.userPortfoliosFetching && (!props.portfoliosLoaded || fiveMinutesAgoOrMore(portfolio.lastUpdate))) {
      portfolioActions.loadUserPortfolios(user.profile.uid)
    }

    // If we have some basics about the portfolio
    if (props) {
      if (props.currentPortfolio) {
        // see if we have balances and fetchem if don't
        if (!props.currentBalances && !props.balancesLoaded) {
          balancesActions.fetchBalances(props.currentPortfolio)
            .then(result => {
              // console.info('result of balances:', result)
            })
        }
      }
    }
  }

  render () {
    const Children = () => this.props.children
    return (
      <Paper className='pm-wrap' zDepth={1}>
        {false && (<div>
          <h3>Debug</h3>
          <pre>
            {JSON.stringify(this.props.nextProps, 1, 1)}
          </pre>
        </div>)}
        <Children />
      </Paper>
    )
  }
}

function mapStateToProps (state, ownProps) {
  const { user, portfolio, balances } = state

  const routePid = ownProps.params.pid
  const nextProps = {
    hasUser: !!(user && user.profile),
    userPortfoliosFetching: !!(portfolio && portfolio.userPortfoliosFetching),
    portfoliosLoaded: !!(portfolio && portfolio.lastUpdate),

    currentPortfolio: (portfolio && portfolio.hasUserPortfolios && (routePid || portfolio.activePortfolio || portfolio.userPortfolios[0]))
  }

  if (nextProps.currentPortfolio) {
    nextProps['currentBalances'] = balances && balances.byPid && balances.byPid[nextProps.currentPortfolio]
    nextProps['balancesLoaded'] = !!(nextProps.currentBalances && nextProps.currentBalances.lastUpdate)
  }

  return {
    ...nextProps,
    user: state.user,
    portfolio: state.portfolio,
    balances: state.balances && state.balances.byPid,
    userPortfolios: state.portfolio && state.portfolio.portfolios && state.portfolio.userPortfolios && state.portfolio.portfolios
      .filter(pf => state.portfolio.userPortfolios.indexOf(pf.portfolio.pid) !== -1)
  }
}

function mapDispatchToProps (dispatch) {
  return {
    portfolioActions: bindActionCreators(portfolioActions, dispatch),
    balancesActions: bindActionCreators(balancesActions, dispatch)
  }
}

export default connect(mapStateToProps, mapDispatchToProps)(Wrap)
